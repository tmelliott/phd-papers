\section{Working with \rt transit data}
\label{sec:gtfs}

GTFS (general transit feed specification)
is an API (application programming interface) specification for transit data
detailing how it should be organised,
making access easier for application developers.
Developed and maintained by Google \citep{GoogleDevelopers_2006},
who use it in Google Maps Transit Directions,
it is used by over 1100~transit providers around the world\footnote{%
source: \url{http://transitfeeds.com} as of August 2019},
including here in Auckland, New Zealand.
An advantage of this standardised format is that,
provided an application depends solely on GTFS data,
after developing it locally in Auckland it can be deployed to any other GTFS-based
public transport system with minimal modification.


There are two components to GTFS.
The first, \emph{GTFS static}, includes information about
\begin{itemize}
\item \emph{stops}, a physical location where passengers can embark and disembark the vehicle;
\item \emph{routes}, a sequence of two or more stops displayed as a single service;
\item \emph{trips}, an instance of a route occurring at a specific time of day;
\item \emph{schedules}, specifying the arrival (and departure) times for each bus at each of its stops; 
\item and \emph{shapes}, the sequence of points defining a vehicle's path along a route.
\end{itemize}
The second component is \emph{GTFS-realtime},
which is only available in a subset of the providers due to the requirement of 
on board GPS tracking devices and a central server.
It provides a standardised format for sharing vehicle positions and trip delays,
and are typically accessed by developers via an API can be used in \rt applications.

As mentioned in Section~\ref{sec:intro},
there are some major issues with the current prediction method in Auckland.
These are almost directly attributed to \emph{GTFS-realtime} trip updates,
which are currently the sole source of data for ETAs.
Trip updates are reported whenever a vehicle arrives or departs a stop,
and includes the delay between the scheduled and actual arrival times,
which is propagated to all future stops to update their ETAs.
This assumes that the schedule is well calibrated 
and the scheduled travel time between stops
is representative of the real-world travel time between them. 
Therefore, an alternative estimation approach that uses \rt travel times 
between stops would seem more adequate.



\subsection{Transit network construction}
\label{sec:network_build}

The primary predictor of arrival time is 
the travel time along roads between where the bus is \emph{now},
and the stop at which the passenger is waiting.
In most applications, however, this vital information is unavailable, at least directly.
In order to compute travel times efficiently
and make use of all available data pooled across multiple routes,
we constructed a \emph{road network},
allowing us to model each physical road as a unique entity.
In this way, every bus travelling along a road contributes to its state,
and can be used to predice travel times for all upcoming buses 
travelling along the road,
irrespective of the route they are servicing.


The transit network was constructed by splitting each route
into spatially identifiable segments,
each representative of a physical road,
by using bus stops as nodes in the network
and the connecting roads as edges
(Figure~\ref{fig:network_creation}).
In this way, routes that service the same subsequence of stops
all contribute to congestion information for the connecting roads.
Although there are several drawbacks to this method,
such as road segment overlaps where routes merge between stops,
this is minimal and our approach is sufficient for the current work.



\begin{figure}[tb]
    \centering
    \begin{subfigure}{0.7\textwidth}
        \centering
        \includegraphics[width=0.95\textwidth]{figures/02_network_segments_1.pdf}
        \caption{Raw GTFS route shapes}
        \label{fig:network_creation_1}
    \end{subfigure} \\
    \begin{subfigure}{0.7\textwidth}
        \centering
        \includegraphics[width=0.95\textwidth]{figures/02_network_segments_2.pdf}
        \caption{GTFS-based road network}
        \label{fig:network_creation_2}
    \end{subfigure}
    \caption{
        Bus stops (shown as dots above) can be serviced by more than one route, 
        as shown in (a), with different line types representing three separate routes.
        The constructed road network, using stops as nodes, is shown in (b),
        in which the connecting lines represent physical road segments,
        with line width proportional to the number of individual routes 
        travelling along that road.
    }
    \label{fig:network_creation}
\end{figure}


\subsection{Real-time vehicle locations}
\label{sec:realtime_data}

\emph{GTFS-realtime} provides the positions of vehicles in a transit network.
The data consists of the time $t_k$ that the position was last updated,
the GPS position of the vehicle, $\bY_k$, 
and information about the trip being serviced.
In Auckland, vehicle positions are updated with a frequency of anywhere between 10~seconds and several minutes,
so there is often a lot of uncertainty about a vehicle's intermediate trajectory,
particularly when there are one or more bus stops along the way.
It is also possible for a bus to remain stationary,
for example due to heavy congestion,
so the number of possible trajectories rapidly increases with 
the time between observations.


One important consideration regarding Auckland Transport's \rt implementation is that
buses are programmed to report their location when arriving at or departing from
bus stops, as well as some major intersections.
To further complicate this,
these positions can be preemptive,
for example when approaching a queue of traffic at an intersection
and the way-point is triggered before the bus physically gets there,
so consecutive observations can show a bus travelling backwards.
To handle this, we compute the approximate distance travelled, $\tilde x_k$,
of the vehicle by finding the nearest point on the path to the observation;
if this has decreased, the current state is rejected and the vehicle reverted
to its previous state before continuing.
We are available to avoid degeneration of the particle filter (Section~\ref{sec:model_perf})
at the cost of losing one observation that is most likely invalid anyway.

