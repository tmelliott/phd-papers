\documentclass[times, doublespace]{anzsauth}
\usepackage{moreverb}
\usepackage{url}
\usepackage{grffile}
\usepackage{lineno}
% \usepackage{lmodern}
\usepackage{lipsum}
\usepackage[UKenglish]{isodate}

\input{../glossary.tex}

\def\volumeyear{2018}
\linenumbers

\begin{document}
\cleanlookdateon
\runningheads{Short title of paper}{TOM~ELLIOTT AND THOMAS~LUMLEY}
\title{Long name of the paper}
\author{Tom Elliott\corrauth~and~Thomas~Lumley}
\affiliation{University of Auckland}
\address{
    Department of Statistics, University of Auckland, 
    Auckland 1142, New Zealand\\
    Email: \texttt{tom.elliott@auckland.ac.nz}
}

\begin{abstract}
Predicting transit vehicle arrival time is a somewhat complex procress.
Road networks are dynamic, and can change from free-flowing to highly congested
very quickly.
Any reliable prediction framework needs to be able to respond to these changes,
but also to future trends, such as typical changes to traffic flow
at peak times, based on hisorical data.
Of course, the major constraint on any prediction framework is going to be
computational efficiency.
Due to the realtime nature of the problem, predictions need to be 
available as soon as possible after observing the vehicles' positions,
which are updated approximately every 30~seconds.
In this paper, we describe our C++ implementation of a particle filter to estimate
vehicle state in combination with a network state model,
allowing us to model transit vehicle flow through the network.
While our application here is being testing in Auckland, New Zealand,
we hope that our methods are general enough to be applied to any
transit network that uses GTFS.
Preliminary results show that, with suitable hardware,
the framework is fast enough while retaining the complexity necessary
to incorporate as much information as necessary to predict arrival times.
\end{abstract}

\keywords{particle filter; Kalman filter; transit modeling;
          transit networks; statistical computing; applications; gtfs}

\maketitle
\section{Introduction}
\label{sec:intro}


The need for realtime information.
Where it goes wrong: 
- bad schedule calibration;
- no accounting for realtime traffic 
- mention how only the delays are used (in Akl), which rely on (often inaccurate) schedules
Literature review of historical and present methods?

% Bus arrival-time prediction is far from a novel concept: 
% ever since the first vehicle tracking technology was implemented
% in transit vehicles in the late 1980's, 
% real-time models have been implemented to provide \gls{rti} for commuters.
% The simplest form of this is, the \gls{eta}
% (usually displayed as \emph{minutes until arrival}),
% was implemented in {{region}} by \cite{Wall99analgorithm} 
% using their proposed \gls{kf} algorithm.
% In their work, they used historical data to obtain \glspl{eta}.

% Over the years, advances in computing power have enabled new
% modeling approaches,
% such as support vector machines \citep{Yu_2006},
% artificial neural networks \citep{Yu_2011},
% and more recently particle filters \citep{Hans_2015}.



Particle filter has proven useful to this kind of dynamic problem,
where the state distribution is non-gaussian, non-symmetric, 
multimodal...

Any other recent attempts at network-estimation?
There was a KF using point-to-point speed estimations? 

Computational aspect - historically, models had to be simple 
(e.g., KF) so they could run in realtime.
These days, running a somewhat powerful VM on a remote server
is almost standard practice, so we can take full advantage 
and use a more computationally demanding (particle filter)
but more accurate estimation technique - paired with a more complex model.

We first give an overview of the transit network,
and how we construct it from raw GTFS shape data.
This paper assumes a very basic model,
with a focus on the implementation in a realtime setting.




\section{Working with GTFS data}
\label{sec:gtfs}

GTFS (general transit feed specification)
is an API (application programming interface) specification for transit data,
developed and maintained by Google \citep{GoogleDevelopers_2006}.
It is used by over 900~transit providers around the world,
including here in Auckland, New Zealand
(source \url{http://transitfeeds.com}),
allowing an application developed locally to
be deployed to another GTFS-based public transport system with minimal modification.


The two main components of GTFS are \emph{static} and \emph{realtime}.
Static GTFS includes information about routes, trips, shapes, and stops:
a \emph{route} is a sequence of two or more stops displayed as a single service;
a \emph{trip} is an instance of a route occuring at a specific time of day;
a \emph{shape} is the sequence of points defining a vehicle's path along a route;
and a \emph{stop} is a physical location where passengers can embark and disembark
the vehicle.
GTFS realtime feeds provide information such as vehicle positions and trip delays,
and are usually accessed via an API.
% The latter is often the only covariate used for predicting arrival time,
% as previously discussed:
% while it is a computationally inexpensive method (simply addition),
% it relies on accurate schedules and cannot respond quickly to realtime events.


\subsection{Transit network construction}
\label{sec:network_build}

Arguably one of the most important predictors of arrival time is
the travel time along intermediate roads,
however in most applications this vital information is unavailable,
at least directly. 
Several predictive approaches used \emph{headway},
the time between consecutive trips along the same route
\citep{Hans_2015}.
While this is reasonable for high frequency routes,
low frequncy routes will be unable to react quickly to changes in congestion,
and it is for these routes which reliable ETAs are arguably more important,
since the cost of missing a bus is greater.


One solution would be to use information obtained from
vehicles servicing other routes but traveling along the same roads
to estimate arrival times;
however, there is no direct way of knowing which routes share common roads.
We are propose using an algorithm to convert the raw GTFS shape files
into a \emph{road network},
as demonstated in Figure~\ref{fig:network_creation}.
This involves detecting locations where one or more routes meet 
(intersections or \emph{nodes}),
and the connecting paths (road segments or \emph{edges}).






% Before we can usefully model buses in real-time, 
% we need to construct a \emph{transit network},
% consisting of \emph{intersections} (nodes)
% connected by \emph{road segments} (edges).
% In this way, each \emph{route} 
% (a journey taken by a transit vehicle, from an origin to a destination by a fixed path)
% can be represented as a sequence of road segments,
% each of which we model as vehicles travel along them (see section~\ref{sec:kf}).



\subsection{Realtime vehicle locations}
\label{sec:realtime_data}

GTFS realtime allows developers to query the current positions of vehicles
in the transit network.
The data consists of the time $t_k$ that the observation was made,
the GPS position of the vehicle, $Y_k$, 
and some other information about the trip being serviced.
Vehicle positions are usually updated within 30~seconds,
but this can vary from 10~seconds to several minutes,
so there is often a lot of uncertainty about the trajectory
between two observations, particularly when there is a bus stop
or intersection between them.

Another complication with the Auckland Transport realtime feed is that
the buses are programmed to report their location when arriving at
bus stops and some major intersections.
Often these positions appear to be preemptive (i.e., that bus is almost there, 
but not quiet),
and subsequent observations place the bus \emph{behind} the stop or intersection.
This must therefore be accounted for in the model proposed in the next section.




\section{The Models}
\label{sec:models}

\subsection{Real-time vehicle model}
\label{sec:pf}

In order to estimate vehicle speed from a series of noisy GPS observations,
we need a model capable of overcoming several key problems:
varying update intervals, multimodality, assymetry, 
and some other artefacts such as mentioned in Section~\ref{sec:realtime_data}.
One estimation technique that suits itself well to this type of problem
is the particle filter, 
which has been used in several other bus modeling applications
\citep{Hans_2015}.
The primary advantage of this approach is that we need not make any 
unnecessary assumptions, particularly on the shape of the distributions 
as is the case in other commonly used methods such as the Kalman filter.


To generate arrival time predictions, 
several aspects of the vehicle's \emph{state} need to first be estimated,
such as its speed.
The \emph{unmeasurable state} of a vehicle at time $t_k$ is denoted by
\begin{equation}
    X_k = \begin{bmatrix} x_k & \dot x_k & \ddot x_k \end{bmatrix}^\top,
\end{equation}
where $x$ is the distance traveled along a route,
$\dot x$ is the speed (the first derivative of distance traveled as a function of time),
and $\ddot x$ is acceleration (the second derivative).

The next state is modeled as a function of the current state,
using a transition function $f$


\subsection{Network model}
\label{sec:kf}

Two parts to this - first, the prior prediction step; then, the data update step.


\section{Implementing in realtime}
\label{sec:rt}

How we implement it, choice of software (Rcpp = R + C++).
R: dealing with data structures is easier, maintainability, interfacing
C++: speed

Overall structure:
- load
- fetch positions
- initialize or mutate+update
- update network
- make ETA predictions (vehicle state + network state)

Some of the key things:
- minimise copy, parallelisation using OMP
- moving as much computation ``outside'' of the main loop as possible
  (e.g., ``pre''-predict vehicle/network states so only update required)
  so ETAs are generated ASAP after retrieving data
- keeping the GTFS database up-to-date by fetching new data each morning
- distribution - a cloud database vs a single protobuf file with everything 
  (maintenance/reliability/speed/size)


\section{Preliminary Results}
\label{sec:results}

Currently only have timings (i.e., yes this is plausible).
- Function of number of particles/number of cores/number of buses.
- Network coverage? i.e., how many road segments actually get enough data
to generate useful numbers

- any problems?


\section{Discussion and Future Work}
\label{sec:discussion}

It all seems to work (hopefully I don't need to change this D:)

Next steps include
- generating useful priors for ``fall back'' (i.e., no data, future) prediction
- develop and implement a more complex network update model (correlations, etc)
- prediction estimates (point vs interval)

\cite{Hans_2015}


\bibliographystyle{anzsj}
\bibliography{../reflist.bib}

\end{document}
