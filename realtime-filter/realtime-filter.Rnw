%\documentclass{IEEEtran}
\documentclass[draftcls,a4paper,onecolumn]{IEEEtran}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{bm}
\usepackage{bbm}
\usepackage{subfig}

\input{../symbols.tex}
\input{../glossary.tex}


\title{Modelling the Real Time State of a Public Transport Road Network}
\author{Tom~Elliott}

\begin{document}

\maketitle


\begin{abstract}
  Model all vehicles in the public transport system in real time.
  Particle filter model for each vehicle (bus),
  using observations of position (GPS coordinates) to infer distance into trip
  and velocity.
  Then use particle filter estimates of vehicle speed to estimate bus speed along
  road segments, independently of route.
  
\end{abstract}



\begin{IEEEkeywords}
  Public transport, real-time, particle filter, kalman filter
\end{IEEEkeywords}

\section{Introduction}
\label{sec:intro}


Modelling busses in real-time has been done for a while now.
Modelling the underlying state of the road network in order to improve 
travel time predictions has not been explored \ldots
Some looking into complex models for ``future'' travel times \cite{Julio2016}.


The basic idea:
GPS position $\rightarrow$ 
vehicle state (distance, segment, speed) $\rightarrow$
road segment state (speed) $\rightarrow$
travel time predictions



\section{The Data: GTFS database and route segmentation}
\label{sec:data}

Transit data has become increasingly accessible over the year.
Attibuted mostly to Google's \gls{gtfs}.
Two components to \gls{gtfs}: static and real-time.

Static contains information about routes, trips (one instance of a route at a scheduled time of day),
stop positions, stop times, route shapes.

Real-time provides vehicle positions (as GPS coordinates),
and trip updates (including stop time updates, i.e., arrival and departure times/delays).
Updated typically every 30~seconds or so.

Modelling a single trip or route is fairly simple to do with the raw \gls{gtfs} data.
However, difficult to combine information from different routes traveling along the same road segments.

We define a \emph{road segment} as a stretch of road used in a transit route between two intersections,
\emph{or} between a start/end stop of a route and an intersection.

Do this by identifying all intersections
(approximated by all traffic lights for now, since that's the data we have)
and segment routes at these points.
Modify \gls{gtfs} data so \emph{shapes} table becomes
\texttt{shapes}, \texttt{segments}, and \texttt{segment\_shapes}.

Thus as we add new routes, we don't need to create new segments
(except at start/end\ldots see section~\ref{sec:discussion}).


<<route_segmentation,echo=FALSE,out.width='0.5\\linewidth',fig.cap="Simplified unidirectional road network diagram, with (a) overlapping routes, and (b) the segments obtained by splitting the routes at intersections. Route 1 $ = \\{r_1, r_2, r_3\\}$, route 2 $=\\{r_4,r_2,r_5,r_6\\}$, and route 3 $=\\{r_7,r_5,r_8,r_9\\}$.",fig.scap="Simplied diagram of overlapping routes",fig.subcap=c("Routes","Segments")>>=
par(mar = rep(2.1, 4))
e <- 0.01
r1 <- rbind(c(0.5, 1), c(1 - e, 1), c(1 - e, 2), c(1 - e, 2.5))
r2 <- rbind(c(1 + e, 0.5), c(1 + e, 1), c(1 + e, 2 - e), c(2, 2 - e), c(2.5, 2 - e))
r3 <- rbind(c(0.5, 2 + e), c(1, 2 + e), c(2 + e, 2 + e), c(2 + e, 1), c(2 + e, 0.5))
grid <- rbind(c(1, 1), c(1, 2), c(2, 1), c(2, 2))

plot(grid, xlim = c(0.5, 2.5), ylim = c(0.5, 3), type = "n",
     xaxs = "i", yaxs = "i", bty = "n", xaxt = "n", yaxt = "n",
     xlab = "", ylab = "", pch = 19, asp = 1)
pal <- RColorBrewer::brewer.pal(3, "Dark2")
arrows(1-e, 2, 1-e, 2.5, lwd = 5, col = pal[1], length = 0.15)
arrows(2, 2-e, 2.5, 2-e, lwd = 5, col = pal[2], length = 0.15)
arrows(2+e, 1, 2+e, 0.5, lwd = 5, col = pal[3], length = 0.15)
lines(r1, col = pal[1], lwd = 5)
lines(r2, col = pal[2], lwd = 5)
lines(r3, col = pal[3], lwd = 5)
legend("topright", legend = paste("Route", 1:3),
       col = pal, bty = "n", lwd = 5, cex = 2)

plot(grid, xlim = c(0.5, 2.5), ylim = c(0.5, 3), type = "n",
     xaxs = "i", yaxs = "i", bty = "n", xaxt = "n", yaxt = "n",
     xlab = "", ylab = "", pch = 19, asp = 1)
ea <- 0.06
arrows(c(0.5, 1, 1,  
         1, 1+ea, 2+ea,  
         0.5, 2, 2),
       c(1, 1+ea, 2+ea,  
         0.5, 2, 2,  
         2, 2-ea, 1-ea),
       c(1-ea, 1, 1,  
         1, 2-ea, 2.5,  
         1-ea, 2, 2),
       c(1, 2-ea, 2.5,  
         1-ea, 2, 2,  
         2, 1+ea, 0.5), 
       code = 2, length = 0.15,
       lwd = c(2, 4, 2,  2, 4, 2,  2, 2))
#points(grid, pch = 19, cex = 4, col = "white")
points(grid, pch = 19, cex = 2, col = "black")

tx <- rbind(c(0.7, 1.1), c(0.9, 1.5), c(0.9, 2.3),
            c(1.1, 0.7), c(1.5, 2.1), c(2.3, 2.1),
            c(0.7, 1.9), c(2.1, 1.5), c(2.1, 0.7))
for (i in 1:nrow(tx)) {
    text(tx[i,1], tx[i,2], 
         substitute(r[x], list(x = i)),
         cex = 3, family="serif", font=3)
}
     
@ 



\section{Real-time vehicle model: particle filter}
\label{sec:pf}

Need to estimate vehicle state at time $t_k$, $\bX_k = [d_k, v_k, \ldots]$, 
from observations, $\bY_k = [\phi_k, \lambda_k]$.
Use a transition function to predict,
likelihood function to weight and update (via weighted resample).


\subsection{Predict: transition function}
The idea behind using particle filter (as opposed to other models)
is that it is well suited modelling busses \cite{Hans2015},
as it has good coverage of the plausible locations and thus overcomes
many problems associated with modelling transit vehicles,
such as multimodality (due to loops, traffic lights, and stops).

Also easy to describe the model;
only have to deal with an individual object (particle) which follows laws of physics.
Rather than dealing with a state \emph{distribution}.

Downside is computational demand.

Algorithm~1 describes the particle filter transition algorithm that
describes the motion of a bus between observations.



\subsection{Update: weighted resampling}


Several pieces of data: position, arrival time, and departure time.

For position, need to allow bus to be ``at stop'' (but not exactly),
or ``queued up at an intersection''.

For arrival/departure times, when the data is there, it's fairly easy;
however, if data is \emph{missing}, we don't know whether bus hasn't arrived yet,
or if bus didn't report arrival.
Also if bus doesn't report both arrival time and departure time,
don't know if it simply didn't stop (i.e., arrival = departure),
or if we missed one of them.

So, depending on the data, we apply different likelihood functions.


\subsubsection[L1]{$L_1$: not at a stop or intersection}

In situations where the bus is neither at a bus stop nor at an intersection,
the likelihood is simply determined from the distance between the particle and 
vehicle's reported position.
The particle filter framework makes this easy,
as each particle has a single value of distance into trip, $d_k^{(i)}$,
with which we can compute the latitude and longitude values based on 
the routes shape information, $z_k^{(i)} = h(d_k{(i)})$.


\subsubsection[L1b]{$L_1'$: at stop}

If the particle is considered to be at a stop, then we apply the following likelihood.
Define a parameter $\varepsilon_S$ as a boundary around the stop;
if observation is within that boundary likelihood is 1, else 0.


\subsubsection[L1c]{$L_1''$: at intersection}

If the particle is considered to be at an intersection, we apply the following likelihood.
Similar to $L_1'$, however need to check observation is heading into the intersection
(and not out of it) by using two boundaries around the intersection and a point $\varepsilon_I$ away.


Then 
\begin{equation}
  L_1(\bX_k^{(i)} | \bY_k) =
  \begin{cases}
    \frac{1}{2\pi\sigma_y} e^{\frac{\|g(h(d_k^{(i)})|\bY_k)\|^2}{2\sigma_y^2}} & \text{ if particle neither at stop nor intersection } \\
    \frac{1}{c} \mathbbm{1}_{d(h(S_{s_k{[i]}}^d), Y_k) < \varepsilon_S}    & \text{ if particle at stop } \\
    \frac{1}{c} \mathbbm{1}_{d(h(R_{r_k{[i]}}^d), Y_k) < \varepsilon_I \cap d(h(R_{r_k{[i]}}^d-\varepsilon_I), Y_k) < \varepsilon_I}    & \text{ if particle at intersection }
  \end{cases}
\end{equation}


\subsubsection[L2]{$L_2$: not at a stop}

If the particle is not at a stop, we determine a likelihood for the arrival and departure
times at the last stop, if they are available.

First check that the most recent stop time update agrees with the particle;
if the stop time update is for stop $j$, and the particles state has $s_k^{(i)} < j$,
then the particle is not plausible;
otherwise use normal distribution for arrival and departure times,
or whichever are available.


\subsubsection[L2b]{$L_2'$: at a stop}

If particle is at a stop, again determine whether or not it agrees with data.
If it does, then check data doesn't imply particle has departed,
then just use likelihood on arrival time.



\section{Real-time transport road network model: Kalman filter}
\label{sec:kf}

Now that each vehicle is modelled by a sample of particles,
we can use the speed estimates of busses along segments to estimate
the speed along them, regardless of the route.
In future we can add correlation structure between adjacent segments.

Use Kalman filter because we have one parameter, speed, 
which we expect to be unimodal and approximately Gaussian
(some busses travel faster or slower).

Use weighted speed estimates as data,
and weighted variance as measurement error.


We run the Kalman filter every time we run the particle filter,
since it has a low cost, allowing the most recent data to be incorporated.
We have $N$ weighted particle estimates of vehicle state for each bus,
with which we can compute the mean distance into trip and velocity for bus $j$,
\begin{equation}
  \label{eq:weighted_mean}
  \bar d_j = \sum_{i=1}^N w_j^{(i)} d_j^{(i)} \quad\text{and}\quad
  \bar v_j = \sum_{i=1}^N w_j^{(i)} v_j^{(i)},
\end{equation}
as well as the weighted sample variance \cite{cn},
\begin{equation}
  \label{eq:weighted_variance}
  \bar S_j^2 = \frac{\sum_{i=1}^N w_j^{(i)} (v_j^{(i)} - \bar v_j)^2}{1 - \sum_{i=1}^N (w_j^{(i)})^2},
\end{equation}
since $\sum_{i=1}^N w_j^{(i)} = 1\quad \forall j$.

Using $\bar d_j$, we can find the segment id corresponding to each busses most probable location,
and then combine all vehicle speed estimates for each segment.

In situations where multiple vehicles are in the same segment $\ell$, 
we can simply combine the estimates, using $M_\ell = $ number of vehicles in segment $\ell$ 
\cite{cn}.
\begin{equation}
  \label{eq:kf_data_estimates}
  \bar z_\ell = \frac{1}{M_\ell} \sum_{j = 1}^{M_\ell} \bar v_j \quad\text{and}\quad
  \hat \bR_{\ell,\ell}^2 = \frac{1}{M_\ell} \sum_{j=1}^{M_\ell} \left(\bar v_j^2 + \bar S_j^2\right) - \hat v_\ell^2
\end{equation}

Next is just the simple matter of applying the Kalman filter algorithm to the transport road network state,
using the data $\bz_k$ as the observation and $\bR_k$,
as the measurement error matrix.


\section{Arrival time prediction: application to a small subset of routes}
\label{sec:results}


Compare several methods:
current delay, current speed, and Kalman filter speed estimates.
Also include dwell distibutions at stops and intersections.



\section{Discusion and Future Work}
\label{sec:discussion}

\begin{itemize}
\item removing ``partial'' segments at start/end of routes
\end{itemize}



\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,../reflist.bib}


\end{document}
