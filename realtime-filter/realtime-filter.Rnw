%\documentclass[9pt]{IEEEtran}
\documentclass[draftcls,a4paper,onecolumn]{IEEEtran}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{bm}
\usepackage{bbm}
\usepackage{subfig}
\usepackage{algpseudocode}
\algblockdefx[Phase]{Phase}{EndPhase}[2]{\textbf{Phase #1:} #2}%
{\textbf{End Phase}\\}
%\usepackage{longtable}
\usepackage{xtab,booktabs}

\usepackage{cite}

\input{../symbols.tex}
\input{../glossary.tex}


\title{Real-time modelling of a public transport network to improve arrival-time predictions}
\author{Tom~Elliott}

\begin{document}

\maketitle


\begin{abstract}
  Model all vehicles in the public transport system in real-time.
  Particle filter model for each vehicle (bus),
  using observations of position (GPS coordinates) to infer distance into trip
  and velocity.
  Then use particle filter estimates of vehicle speed to estimate bus speed along
  road segments, independently of route.
 
\end{abstract}



\begin{IEEEkeywords}
  Public transport, real-time, particle filter, kalman filter, road state
\end{IEEEkeywords}

\section{Introduction}
\label{sec:intro}


Modelling busses in real-time has been done for a while now 
\cite{Cats_2015,Chen_2014,Hans_2015,Jeong_2005,TCRP_2003,Wessel_2016,
  Xinghao_2013}.
Modelling the underlying state of the road network in order to improve 
travel time predictions has not been explored \ldots
Some looking into complex models for ``future'' travel times 
\cite{Julio_2016,Xinghao_2013,Yichen_Zheng_2016,Yu_2011}.


The basic idea:
GPS position $\rightarrow$ 
vehicle state (distance, segment, speed) $\rightarrow$
road segment state (speed) $\rightarrow$
travel time predictions



\section{The Data: GTFS database and route segmentation}
\label{sec:data}

Transit data has become increasingly accessible over the year.
Attibuted mostly to Google's \gls{gtfs} \cite{GoogleDevelopers_2006}.
Two components to \gls{gtfs}: real-time and static.

Real-time provides vehicle positions (as GPS coordinates),
and trip updates (including stop time updates, 
i.e., arrival and departure times/delays).
Updated typically every 30~seconds or so,
and is used by the real-time model (section~\ref{sec:pf}).

Static contains information about routes, 
trips (one instance of a route at a scheduled time of day),
stop positions, stop times, route shapes.

Modelling a single trip or route is fairly simple to do with 
the raw \gls{gtfs} data.
However, difficult to combine information from different routes 
traveling along the same road segments.
Some attempts \cite{Yu_2011}, but assumes knowledge of converging routes.

We define a \emph{road segment} as a stretch of road used 
in a transit route between two intersections,
and partial segments between a start/end stop of a route 
and an intersection.
Add max segment length to attempt to reduce within-segment variability 
on roads with few intersections (e.g., highways).

Do this by identifying all intersections,
which can be downloaded from \gls{osm} \cite{OpenStreetMap_2017}
and segment routes at these points,
as shown in figure~\ref{fig:route_segmentation}.
For now, only using traffic lights and roundabouts 
(as these are easy to access from \gls{osm}).
Modify \gls{gtfs} data
by adding \texttt{intersections}, \texttt{segments}, and \texttt{shape\_segments} tables.
We assume that if two routes both go through intersections $A$ and $B$,
they follow the same road to do so
(once we scale up to all intersections, this will be true almost surely).
We also allow segments to begin or end at a bus stop, 
which allows routes with the same origin or destination to share segments.



<<route_segmentation,echo=FALSE,out.width='0.5\\linewidth',fig.cap="Simplified unidirectional road network diagram, with (a) overlapping routes, and (b) the segments obtained by splitting the routes at intersections (solid dots). Route 1 $ = \\{R_1, R_2, R_3\\}$, route 2 $=\\{R_4,R_2,R_5,R_6\\}$, and route 3 $=\\{R_7,R_5,R_8,R_9\\}$.",fig.scap="Simplied diagram of overlapping routes",fig.subcap=c("Routes","Segments")>>=
par(mar = rep(2.1, 4))
e <- 0.01
r1 <- rbind(c(0.5, 1), c(1 - e, 1), c(1 - e, 2), c(1 - e, 2.5))
r2 <- rbind(c(1 + e, 0.5), c(1 + e, 1), c(1 + e, 2 - e), c(2, 2 - e), 
            c(2.5, 2 - e))
r3 <- rbind(c(0.5, 2 + e), c(1, 2 + e), c(2 + e, 2 + e), c(2 + e, 1), 
            c(2 + e, 0.5))
grid <- rbind(c(1, 1), c(1, 2), c(2, 1), c(2, 2))

plot(grid, xlim = c(0.5, 2.5), ylim = c(0.5, 3), type = "n",
     xaxs = "i", yaxs = "i", bty = "n", xaxt = "n", yaxt = "n",
     xlab = "", ylab = "", pch = 19, asp = 1)
pal <- RColorBrewer::brewer.pal(3, "Dark2")
arrows(1-e, 2, 1-e, 2.5, lwd = 5, col = pal[1], length = 0.15)
arrows(2, 2-e, 2.5, 2-e, lwd = 5, col = pal[2], length = 0.15)
arrows(2+e, 1, 2+e, 0.5, lwd = 5, col = pal[3], length = 0.15)
lines(r1, col = pal[1], lwd = 5)
lines(r2, col = pal[2], lwd = 5)
lines(r3, col = pal[3], lwd = 5)
legend("topright", legend = paste("Route", 1:3),
       col = pal, bty = "n", lwd = 5, cex = 2)

plot(grid, xlim = c(0.5, 2.5), ylim = c(0.5, 3), type = "n",
     xaxs = "i", yaxs = "i", bty = "n", xaxt = "n", yaxt = "n",
     xlab = "", ylab = "", pch = 19, asp = 1)
ea <- 0.06
arrows(c(0.5, 1, 1,  
         1, 1+ea, 2+ea,  
         0.5, 2, 2),
       c(1, 1+ea, 2+ea,  
         0.5, 2, 2,  
         2, 2-ea, 1-ea),
       c(1-ea, 1, 1,  
         1, 2-ea, 2.5,  
         1-ea, 2, 2),
       c(1, 2-ea, 2.5,  
         1-ea, 2, 2,  
         2, 1+ea, 0.5), 
       code = 2, length = 0.15,
       lwd = c(2, 4, 2,  2, 4, 2,  2, 2))
points(grid, pch = 19, cex = 2, col = "black")

tx <- rbind(c(0.7, 1.0), c(1, 1.5), c(1, 2.3),
            c(1.0, 0.7), c(1.5, 2.0), c(2.3, 2.0),
            c(0.7, 1.98), c(2.0, 1.5), c(2.0, 0.7))
for (i in 1:nrow(tx)) {
    text(tx[i,1], tx[i,2], 
         substitute(R[x], list(x = i)),
         cex = 2.5, family="serif", font = 3,
         pos=c(3, 2, 2, 4, 3, 3, 1, 4, 4)[i])
}
     
@ 



\section{Real-time vehicle model: particle filter}
\label{sec:pf}

The primary goal of the particle filter is to estimate the unobservatble
vehicle state,
consisting of distance into trip, $x$, 
velocity, $\dot x$,
current stop sequence, $j \in \{1,\ldots,J\}$, 
arrival and dwell times at each stop, 
$\mat A = [A_2, \cdots, A_J]^T$ and 
$\tilde {\mat  D} = [\tilde D_1, \cdots, \tilde D_{J-1}]^T$ respectively
(note that the first stop doesn't have an arrival time,
and the last doesn't have a departure),
current segment index, $\ell$,
the time spent queuing at the intersection at the beginning
of each segment,
$\mat q = [q_2, \cdots, q_L]^T$ (note no queueing time for the first segment),
and the travel time (less dwell time) along each segment,
$\mat b = [b_1, \cdots, b_L]^T$.
The vehicle state at time $k$ is denoted
\begin{equation}
  \label{eq:vehiclestate}
  \bX_k = 
  [x_k, \dot x_k, j, \mat A^T, \tilde{\mat D}^T, \ell, \mat q^T, \mat b^T]^T
\end{equation}

To estimate $\bX_k$, we use the observed data,
which comes from the realtime GTFS feed in two parts:
the first is vehicle position, 
$\tilde y_k = [\mathrm{lng}_k, \mathrm{lat}_l]^T = 
\frac{180}{\pi}[\phi_k, \lambda_k]^T$,
where $\phi$ and $\lambda$ are the latitude and longitude in radians, 
respectively;
the second part is the \emph{stop time updates},
$\mat T_k = [j_k, T_j^a, T_j^d]^T$,
which are the current stop sequence (at time $k$), $j_k$,
the arrival time, $T_j^a$, and departure time, $T_j^d$.
Thus the data obtained at time $t_k$ can be represented by
\begin{equation}
  \label{eq:data}
  \bY_k = [t_k, \tilde y_k, \mat T_k]^T.
\end{equation}
The relationship between the GPS position, $\tilde y$,
and vehicle's distance into trip, $x$,
is denoted by a \emph{measurment function}, 
$\tilde y_k = h(\bX_k) = h(x_k)$,
which depends only on the distance into trip.
The \emph{stop time updates}, $\mat T_k$,
are recorded when the bus arrives or departs a stop;
either or both of the arrival or departure times can be missing.


The particle filter is used to model a transit vehicle,
so we need to know about the behaviour of these.
The vehicle itself has a purpose of driving along an \emph{a priori} known route,
stopping at stops with known location along the way to pick up
and drop off passengers, if there are any.
Between stops, vehicles travel as close to the posted speed limit as possible,
typically only stopping at intersections (if necessary).
Due to many conditional situations, 
the particle filter becomes a vastly superior model when compared to traditional
Kalman filter based methods, 
as it can easily deal with multimodality.

On approach to the $j$th stop along a route, 
$s_j = s(j | \text{route})$,
the bus will stop with probability $\pi_{s_j}$ 
(i.e., it is a bernoulli trial for each particle).
If it stops, it will wait a minimum of $\gamma$ seconds 
while the doors are opened and closed,
and an additional $u$ seconds as passengers board and disembark.
$\gamma$ is considered a fixed parameter, across all busses, 
while $u$ is given an exponential distribution with mean $\tau_{s_j}$.
For now, $\pi_s = \pi$ and $\tau_s = \tau$ $\forall s$
(i.e., every stop has the same stopping probability and mean dwell time; 
section~\ref{sec:discussion} discusses modifications to this).

On approach to an intersection (the end of a segment),
the behaviour is slightly different;
the vehicle doesn't reach the intersection itself, instead it joins the queue
(if there is one), and queues until it is able to pass through.
Similarly to stops, currently this is just modelled using fixed parameter values;
$\rho_{r_\ell}$ is the probability of stopping at the intersection
(for example, green vs.\ red traffic lights),
and $\theta_{r_\ell}$ is the average queue time.
Similiarly to stops, $\rho_r = \rho$ and $\theta_r = \theta$ $\forall r$.


To implement the particle filter model (for a single vehicle $v$), 
we simply initialise $I$ particles 
(using superscript~${(i)}$ to identify an individual particle)
by sampling distance and velocity from a prior distribution
(see section~\ref{sec:results}), 
and the computing the indices,
$j = \arg\max_{j:s_j^d \leq x} \{s_j^d\}$ 
and $\ell = \arg\max_{\ell:r_\ell^d \leq x} \{r_\ell^d\}$ from the 
vectors of stop and segment distances, $\mat s^d$ and $\mat r^d$, respectively.
The remaining state parameters are left uninitialized.
Each particle is then passed through the \emph{transition function}, $f$,
independently (the prediction step),
and then the vehicle state estimate is updated 
using the data by computing likelihood weights
and resampling the particles with replacement.
The steps are described below.

THE ABOVE WILL CHANGE:
\begin{itemize}
\item project each particle to the end of the route,
  including queuing and dwell times
\item update vehicle positions
\item update trip updates
\item each time, reweight (and resample?) based on proximity
\end{itemize}

In our particle filter implementation,
for a single vehicle $v$ we initialize $I$ particles,
and using the superscript $(i) : i = 1, \ldots, I$ to denote 
a value for a single particle.
Each particle is initialized with a full trajectory (see below),
from the begining of the route at time $t_o^{(i)}$ (trip start time is unknown),
until they reach the last stop $s_J$.



\subsection{Predict: transition function}
The idea behind using particle filter (as opposed to other models)
is that it is well suited modelling busses \cite{Hans_2015},
as it has good coverage of the plausible locations and thus overcomes
many problems associated with modelling transit vehicles,
such as multimodality (due to loops, traffic lights, and stops).

Also easy to describe the model;
only have to deal with an individual object (particle) which follows 
laws of physics.
Rather than dealing with a state \emph{distribution}.

Downside is computational demand.

In our chosen approach, a particle represents a full journey,
which allows us to estimate travel times for previous segments, 
as well as produce arrival time predictions in the same step.
The trajectory, which is demonstrated in figure~\ref{fig:trajectory},
is computed at each second of the journey, started at $t_0^{(i)}$.
Each particle is indendently run through a \emph{transition} algorithm,
outlined in figure~\ref{alg:transition}.

<<trajectory,echo=FALSE,out.width='\\linewidth',fig.cap="desc",fig.scap="short desc",fig.width=10,fig.height=5>>=
plot.new()
plot.window(c(0, 600), c(0, 1000), xaxs = "i", yaxs = "i")
axis(2, c(0, 400, 600, 1100), c(0, expression(s[1]^d), expression(r[1]^d), ""), las = 1, family = "serif")
axis(1, c(0, 700), c(expression(t[0]), ""))
mtext("Time (s)", 1, 2)
abline(h = 400, lty = 2, col = "#999999")
abline(h = 600, lty = "7727", lwd = 2, col = "#999999")

@ 


\vspace{1em}\hrule\vspace{1em}

Algorithm~1 describes the particle filter transition algorithm that
describes the motion of a bus between observations.
The $k$ subscripts and $(i)$ superscripts have been dropped from the
vehicle state parameters (e.g., $x \equiv x_k^{(i)}$).

The noise parameter, $\sigma_v^2$
represents system noise, assumed to be small, 
and represents the average change in speed of a bus per second.


\begin{figure}[bt]
  \begin{algorithmic}
    \Function{transition}{$\bX$, $\delta$, $t$}
    
    \Phase{1}{initial wait time}
    \State $w\gets 0$
    \If {$A_s \neq$ NULL $\cap\ D_s =$ NULL}
      \Comment{at stop}
      \State $w\gets w + \max\{0, \gamma - (t - A_s)\}$
      \Comment{min dwell time}
      \State $\bar t \sim \mathcal{E}(\tau^{-1})$
      \State $w\gets w + \bar t, \delta\gets \delta - w$
      \If {$\delta > 0$}
        \State $D_s\gets t - \delta$
        \Comment{depart stop}
      \EndIf
    \ElsIf {$Q_r \neq$ NULL $\cap\ B_r =$ NULL}
      \Comment{at intersection}
      \State $\bar t \sim \mathcal{E}(\kappa^{-1})$
      \State $Q_r\gets Q_r + \bar t$, $w\gets w+\bar t$, $\delta\gets \delta - w$
      \If {$\delta > 0$}
        \State $B_s\gets t - \delta$
        \Comment{pass through intersection}
      \EndIf
    \EndIf
    \EndPhase
    
    
    \Phase{2}{System Noise}
    \State $v_k^{(i)}\sim \mathcal{N}(v, \delta\sigma_v^2)$
    \Comment{add system noise}
    \EndPhase
    
    \Phase{3}{Transition Forward}
    \State see figure~\ref{alg:transitionPhase3}
    \EndPhase
    
    \State \textbf{return} $\bX$
    \EndFunction
  \end{algorithmic}
  \caption{Particle filter transition function. Arguments are vehicle state~($\bX$), time since previous observation~($\delta$), and time of current observation ($t$).}
  \label{alg:transition}
\end{figure}


\begin{figure}[bt]
  \begin{algorithmic}
    \Phase{3}{Transition Forward}
    \While {$\delta > 0$}
      \If {$S^d_{s+1} \leq R^d_{r+1}$}
        \Comment{approaching stop}
        \State ETA  $\gets \frac{1}{v} (S^d_{s+1} - d)$
        \If {ETA $\leq \delta$}
        \Comment{reaches stop}
          \State $\delta\gets \delta - $ ETA, $s \gets s + 1$
          \State $A \gets t - \delta$, $D\gets $ null, $d\gets S^d_s$
          \If {$s = M$}
            \State\textbf{exit}
            \Comment{reached last stop}
          \EndIf
          \State $p\gets \mathcal{B}(\pi)$, $\bar t \sim \mathcal{E}(\tau^{-1})$
          \State dwell $\gets p(\gamma + \bar t)$, $\delta\gets \delta\ - $ dwell
          \If {$\delta > 0$}
            \State $D\gets t - \delta$
            \Comment{departs stop}
          \EndIf
        \Else
          \Comment{doesn't reach stop}
          \State $d\gets d + \delta v$, $\delta \gets 0$
        \EndIf
      \Else
        \Comment{approaching intersection}
        \State ETA $\gets \frac{1}{v}(R^d_{r+1} - d)$
        \If {ETA $\leq \delta$}
          \Comment{reaches intersection}
          \State $\delta\gets \delta - $ ETA, $r\gets r + 1$
          \State $Q \gets 0$, $B\gets $ null, $d\gets R^d_r$
          \State $p \sim \mathcal{B}(\rho)$, $\bar t \sim \mathcal{E}(\kappa^{-1})$
          \State queue $\gets p\bar t$, $\delta\gets \delta\ - $ queue
          \State $Q\gets Q\ +$ queue
          \If {$\delta > 0$}
            \Comment{makes it through intersection}
            \State $B\gets t - \delta$
            \State $v \sim \mathcal{N}(v, \sigma_r^2)$
          \EndIf
        \Else
          \Comment{doesn't reach intersection}
          \State $d\gets d + \delta v$, $\delta \gets 0$
        \EndIf
      \EndIf
    \EndWhile
    \EndPhase
  \end{algorithmic}
  \caption{Transition function, phase 3: the main phase in which particles are moved forwards along the route.}
  \label{alg:transitionPhase3}
\end{figure}



\subsection{Update: weighted resampling}


Several pieces of data: position, arrival time, and departure time.

For position, need to allow bus to be ``at stop'' (but not exactly),
or ``queued up at an intersection''.

For arrival/departure times, when the data is there, it's fairly easy;
however, if data is \emph{missing}, we don't know whether bus hasn't arrived yet,
or if bus didn't report arrival.
Also if bus doesn't report both arrival time and departure time,
don't know if it simply didn't stop (i.e., arrival = departure),
or if we missed one of them.


\subsubsection{GTFS vehicle position}
The likelihood is simply determined from the distance between the particle and 
vehicle's reported position.
The particle filter framework makes this easy,
as each particle has a single value of distance into trip, $x_k^{(i)}$,
with which we can compute the latitude and longitude values based on 
the routes shape information, $z_k^{(i)} = h(d_k^{(i)})$.
The function $g (z | \tilde y)$ performs an \emph{equirectangular projection} 
\cite{Snyder_1998}
of the coordinates $z$, centered on $\tilde y$, 
onto a flat surface so that the Euclidean distance between points is equivalent
to the Great Circle distance between their associated coordinates.
This allows us to use a bivariate normal likelihood on the particles' positions,
with a GPS error of $\sigma_y^2$.

\begin{equation}
  \label{eq:l1}
  \log L_1 (\bY_k | \bX_k^{(i)})
%  = \log L_1 (\tilde y_k | x_k^{(i)})
  = - \log(2\pi\sigma_y) - \frac{\|g(h(x_k^{(i)})|\tilde y_k)\|^2}{2\sigma_y^2}
\end{equation}


\subsubsection{GTFS trip updates}
The second part of the likelihood involves the stop time update,
and how the likelihood is formed depends on what data is available,
where $\bT_k = \left[ j, T^a_j , T^d_j \right]^T$ 
are the stop index, arrival and departure times,
respectively, either of which can be NULL.

We only apply the likelihood when the data is recieved, 
so the two necessary likelihood functions are,
for an arrival time,
\begin{equation}
  \label{eq:l2a}
  \log L_2 (\bY_k | \bX_k^{(i)})
%  = \log L_2 (T_j^a | A_j^{(i)}) 
  = - \frac{1}{2}\log (2\pi\varepsilon^2) - 
  \frac{(T_j^a - A_j^{(i)})^2}{2\varepsilon^2},
\end{equation}
and for a departure time
(note that the departure time for a particle
is simply $D_j^{(i)} = A_j^{(i)} + \tilde D_j^{(i)}$),
\begin{equation}
  \label{eq:l2d}
  \log L_2 (\bY_k | \bX_k^{(i)})
%  = \log L_2 (T_j^d | D_j^{(i)}) 
  = - \frac{1}{2}\log (2\pi\varepsilon^2) - 
  \frac{(T_j^d - D_j^{(i)})^2}{2\varepsilon^2}
\end{equation}


We now determine the likelihood of each particle by combining $L_1$ and $L_2$;
\begin{equation}
  \label{eq:particle_likelihood}
  L (\bY_k | \bX_k^{(i)}) = L_1(\tilde\bY_k|\bX_k^{(i)}) L_2(\bT_k | \bX_k^{(i)}).
\end{equation}
This is then used to compute the weight of each particle,
\begin{equation}
  \label{eq:particle_weights}
  w_i = \frac{L (\bY_k | \bX_k^{(i)})}{\sum_{j=1}^I   L (\bY_k | \bX_k^{(j)})}.
\end{equation}
These weights are then used to perform a weighted resample with replacement.


\section{Real-time transport road network model: Kalman filter}
\label{sec:kf}

Now that each vehicle is modelled by a sample of particles,
we can use the speed estimates of busses along segments to estimate
the speed along them, regardless of the route.
In future we can add correlation structure between adjacent segments.

Use Kalman filter because we have one parameter, speed, 
which we expect to be unimodal and approximately Gaussian
(some busses travel faster or slower).

Use weighted speed estimates as data,
and weighted variance as measurement error.

Want to find the state of all $M$ segments in the network,
\begin{equation}
  \label{eq:kf_state}
  \bbeta = [\beta_1, \cdots, \beta_M]^T
\end{equation}
which is the travel time along each segment,
along with the variance-covariance matrix $\Sigma$.
For now, we are assuming segments are independent,
so $\Sigma$ is a diagonal matrix.


We run the Kalman filter every time we run the particle filter,
since it has a low cost, allowing the most recent data to be incorporated.
For each vehicle $v$, we have $I_v$ particles which we use to
compute the mean distance into trip,
\begin{equation}
  \label{eq:weighted_mean}
  \bar x_v = \sum_{i=1}^{I_v} w_v^{(i)} x_v^{(i)}
\end{equation}
which we can use to estimate which segment the vehicle is in
(using the same method as in the initialisation step).

When the vehicle passes through a segment, $r_\ell$,
we set the travel time of the vehicle using the 
weighted mean and sample variance of the particles,
\begin{align}
  \label{eq:weighted_travel}
  \bar b_{v,\ell} &= \sum_{i=1}^{I_v} w_v^{(i)} b_{v\ell}^{(i)} \\
  \bar S_{v,\ell}^2 &= \sum_{i=1}^{I_v} w_v^{(i)}(b_{v\ell}^{(i)} - \bar b_{v\ell})
\end{align}


Having processed all vehicles, we move on to updating each \emph{segment},
$R_m$, $m = 1, \ldots, M$.
Define
\begin{equation*}
  V_m = \{v:\text{ vehicle $v$ passed through segment } R_m\}
\end{equation*}
and let $K_m$ be the length of $V_m$,
and $\ell(R_m)$ be the segment index of the given stop
(i.e., $\ell(r_\ell) = \ell$).
\begin{align}
  \label{eq:kf_data_estimates}
  \hat B_m &= \frac{1}{K_m} \sum_{v \in V_m} \bar b_{v,\ell(R_m)}  \\
  \hat Q_m &= \frac{1}{K_m} \sum_{v \in V_m} 
  \left(\bar b_{v\ell(R_m)}^2 + \bar S_{v\ell(R_m)}^2\right) - \hat B_m^2
\end{align}

Next is just the simple matter of applying the Kalman filter algorithm 
\cite{Anderson_2012} 
to the transport road network state,
using the data \mbox{$\hat {\mat B}_m = [\hat B_1, \ldots, \hat B_M]$} 
as the observation vector
and \mbox{$\hat {\mat Q}_k = \diag(\hat Q_1, \ldots, \hat Q_M)$},
as the measurement error matrix.
The transition matrix for the network state, $\mat F_c$,
is currently an identity matrix,
but in future we'll allow for the update to account for
changes in adjacent segments.
The Kalman filter prediction equations are
\begin{align}
  \bbeta_{c|c-1} &= \mat F_c\bbeta_{c-1|c-1} \\
  \Sigma_{c|c-1} &= \Sigma_{c-1|c-1} + \bW_c
\end{align}
where $\bW_c \sim \mathcal{N}(0, \delta_c\xi^2\eye_M)$, 
$\xi^2$ is the system noise parameter,
and $\delta_c = t_c - t_{c-1}$ is the time since the segment
was last updated.

The update equations simplify to
\begin{align}
  \bK_c &= \frac{\Sigma_{c|c-1}}{\Sigma_{c|c-1} + \hat {\mat Q}_c} \\
  \bbeta_{c|c} &= \bbeta_{c|c-1} + \bK_c(\hat {\mat B}_c - \bbeta_{c|c-1}) \\
  \Sigma_{c|c} &= (\eye_M - \bK_c) \Sigma_{c|c-1}
\end{align}
which make use of the segment means and variances computed in~(\ref{eq:kf_data_estimates}).


\section{Arrival time prediction}
\label{sec:arrival_time}


Compare several methods:
current delay, current speed, and Kalman filter speed estimates.
Also include dwell distibutions at stops and intersections.


The final step is to predict the arrival time of every bus 
at all remaining stops along their respective routes.
Using the real-time transport network road state, 
we can predict how long it will take a bus to travel 
to each stop.


For segments \emph{without} stops,
we simply sample a travel time from the segment's state estimate
for each particle.
For segments with stops, however,
we only want a \emph{partial} travel time.
Most simply, this is based on proportionally how far into the segment
the stop is.
More complex situations could be investigated in the future,
one example might be to use \emph{sub-segments}.



\section{Application to Auckland Transport}
\label{sec:results}

- mention why weighted estimates stored rather than resampled 
(i.e., to keep trajectories of disbanded particles for analysis).

- model implemented in C++


\section{Discusion and Future Work}
\label{sec:discussion}

\begin{itemize}
\item removing ``partial'' segments at start/end of routes
\item enforcing max length of segments
\end{itemize}


\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,../reflist.bib}


\appendix[List of Symbols]

\begin{xtabular}{ll}
  \toprule
  &\textbf{Data} \\ \midrule
  $t_k$, $t_c$ & time at observation $k$, $c$ \\
  $\delta_x$ & time since last observation, $t_x - t_{x-1}$\\
  $\bY_k$ & observation $k$ \\
  $\tilde y_k$ & GPS position of vehicle (degrees) \\
  $\phi,\lambda$ & latitude, longitude (radians) \\
  $T^a_j, T^d_j$ & arrival, departure time at stop $j \in \{1, \ldots, J\}$ \\
  $S_n$ & unique identifier of stop $n$ \\
  $s_j$, $s_j^x$, $s_j^p$ & unique identifier of $j$th stop (of relevent route), shape distance traveled, position \\
  $R_m$ & unique identifier of segment $m$  \\
  $r_\ell$, $r_\ell^x$, $r_\ell^p$ & unique identifier of $\ell$th segment (of relevent route), shape distance traveled, path \\
  \bottomrule
  \\ \toprule
  &\textbf{Parameters} \\ \midrule
  $\pi$ & probability of stopping at a stop \\
  $\gamma$ & minimum dwell time (seconds) \\
  $\tau$ & mean dwell time (seconds) \\
  $\rho$ & probability of stopping at an intersection \\
  $\theta_m$ & mean queue time (seconds) at intersection of segment $m$ \\
  $\beta_m$ & mean travel time (seconds) for segment $m$ \\
  $\bbeta$, $\Sigma$ & transit network state (mean, covariance) \\
  $\eta$ & stop size (m) \\
  $\kappa$ & intersection size (m) \\
  $\sigma_x$ & system noise (variability in speed) \\
  $\sigma_y$ & GPS error \\
  $\varepsilon$ & arrival/departure time error \\
  $\xi$ & system noise (Kalman filter) \\
  \bottomrule
  \\ \toprule
  &\textbf{Variables} \\ \midrule
  $\bX_k$ & vehicle state associated with obs $k$ \\
  $x$, $\dot x$ & vehicle distance into trip, velocity \\
  $j$, $\ell$ & stop, segment index \\
  $A_j$, $\tilde D_j$, $D_j$ & arrival, dwell, departure time at stop $j$ \\
  $q_j$, $b_j$ & queue, travel time \\
  $z^{(i)}$ & computed GPS position of particle $(i)$ \\
  $p^{(i)}$ & indicator to whether particle $(i)$ stopped \\
  $w$ & particle weight \\
  $B_m$, $Q_m$ & mean, covariance of travel time of all recent vehicles along segment $m$ \\
  $\mat F_c$ & network state transition matrix \\
  $V$, $v$ & number of vehicles, indexed by $v$ \\
  $I$, $i$ & number of particles (per vehicle), indexed by $i$ \\
  $J$, $j$ & number of stops (conditional on route), indexed by $j$ \\
  $L$, $\ell$ & number of segments (conditional on route), indexed by $\ell$ \\
  $N$, $n$ & total number of stops in network, indexed by $n$ \\
  $M$, $m$ & total number of segments in network, indexed by $m$ \\
  $k$ & index for vehicle observations \\
  $c$ & index for transit network state updates \\
  \bottomrule
  \\ \toprule
  &\textbf{Functions} \\ \midrule
  $f$ & vehicle transition function \\
  $h$ & vehicle measurement function \\
  $g$ & equirectangular projection \\
  \bottomrule
\end{xtabular}
  


\vspace{1em}
Times are UNIX timestamps (seconds since 1 Janurary, 1970) unless stated otherwise.

\end{document}
