%\documentclass[9pt]{IEEEtran}
\documentclass[draftcls,a4paper,onecolumn]{IEEEtran}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{bm}
\usepackage{bbm}
\usepackage{subfig}
\usepackage{algpseudocode}
\algblockdefx[Phase]{Phase}{EndPhase}[2]{\textbf{Phase #1:} #2}%
{\textbf{End Phase}\\}

\usepackage{cite}

\input{../symbols.tex}
\input{../glossary.tex}


\title{Modelling the real-time state of a public transport road network}
\author{Tom~Elliott}

\begin{document}

\maketitle


\begin{abstract}
  Model all vehicles in the public transport system in real-time.
  Particle filter model for each vehicle (bus),
  using observations of position (GPS coordinates) to infer distance into trip
  and velocity.
  Then use particle filter estimates of vehicle speed to estimate bus speed along
  road segments, independently of route.
 
\end{abstract}



\begin{IEEEkeywords}
  Public transport, real-time, particle filter, kalman filter, road state
\end{IEEEkeywords}

\section{Introduction}
\label{sec:intro}


Modelling busses in real-time has been done for a while now 
\cite{Cats_2015,Chen_2014,Hans_2015,Jeong_2005,TCRP_2003,Wessel_2016,Xinghao_2013}.
Modelling the underlying state of the road network in order to improve 
travel time predictions has not been explored \ldots
Some looking into complex models for ``future'' travel times 
\cite{Julio_2016,Xinghao_2013,Yichen_Zheng_2016,Yu_2011}.


The basic idea:
GPS position $\rightarrow$ 
vehicle state (distance, segment, speed) $\rightarrow$
road segment state (speed) $\rightarrow$
travel time predictions



\section{The Data: GTFS database and route segmentation}
\label{sec:data}

Transit data has become increasingly accessible over the year.
Attibuted mostly to Google's \gls{gtfs} \cite{GoogleDevelopers_2006}.
Two components to \gls{gtfs}: real-time and static.

Real-time provides vehicle positions (as GPS coordinates),
and trip updates (including stop time updates, 
i.e., arrival and departure times/delays).
Updated typically every 30~seconds or so,
and is used by the real-time model (section~\ref{sec:pf}).

Static contains information about routes, 
trips (one instance of a route at a scheduled time of day),
stop positions, stop times, route shapes.

Modelling a single trip or route is fairly simple to do with the raw \gls{gtfs} data.
However, difficult to combine information from different routes traveling along the same road segments.
Some attempts \cite{Yu_2011}, but assumes knowledge of converging routes.

We define a \emph{road segment} as a stretch of road used in a transit route between two intersections,
and partial segments between a start/end stop of a route and an intersection.
Add max segment length to attempt to reduce within-segment variability on roads with few intersections 
(e.g., highways).

Do this by identifying all intersections,
which can be downloaded from \gls{osm} \cite{OpenStreetMap_2017}
and segment routes at these points,
as shown in figure~\ref{fig:route_segmentation}.
For now, only using traffic lights and roundabouts 
(as these are easy to access from \gls{osm}).
Modify \gls{gtfs} data
by adding \texttt{intersections}, \texttt{segments}, and \texttt{shape\_segments} tables.
We assume that if two routes both go through intersections $A$ and $B$,
they follow the same road to do so
(once we scale up to all intersections, this will be true almost surely).
We also allow segments to begin or end at a bus stop, 
which allows routes with the same origin or destination to share segments.


<<route_segmentation,echo=FALSE,out.width='0.5\\linewidth',fig.cap="Simplified unidirectional road network diagram, with (a) overlapping routes, and (b) the segments obtained by splitting the routes at intersections. Route 1 $ = \\{r_1, r_2, r_3\\}$, route 2 $=\\{r_4,r_2,r_5,r_6\\}$, and route 3 $=\\{r_7,r_5,r_8,r_9\\}$.",fig.scap="Simplied diagram of overlapping routes",fig.subcap=c("Routes","Segments")>>=
par(mar = rep(2.1, 4))
e <- 0.01
r1 <- rbind(c(0.5, 1), c(1 - e, 1), c(1 - e, 2), c(1 - e, 2.5))
r2 <- rbind(c(1 + e, 0.5), c(1 + e, 1), c(1 + e, 2 - e), c(2, 2 - e), c(2.5, 2 - e))
r3 <- rbind(c(0.5, 2 + e), c(1, 2 + e), c(2 + e, 2 + e), c(2 + e, 1), c(2 + e, 0.5))
grid <- rbind(c(1, 1), c(1, 2), c(2, 1), c(2, 2))

plot(grid, xlim = c(0.5, 2.5), ylim = c(0.5, 3), type = "n",
     xaxs = "i", yaxs = "i", bty = "n", xaxt = "n", yaxt = "n",
     xlab = "", ylab = "", pch = 19, asp = 1)
pal <- RColorBrewer::brewer.pal(3, "Dark2")
arrows(1-e, 2, 1-e, 2.5, lwd = 5, col = pal[1], length = 0.15)
arrows(2, 2-e, 2.5, 2-e, lwd = 5, col = pal[2], length = 0.15)
arrows(2+e, 1, 2+e, 0.5, lwd = 5, col = pal[3], length = 0.15)
lines(r1, col = pal[1], lwd = 5)
lines(r2, col = pal[2], lwd = 5)
lines(r3, col = pal[3], lwd = 5)
legend("topright", legend = paste("Route", 1:3),
       col = pal, bty = "n", lwd = 5, cex = 2)

plot(grid, xlim = c(0.5, 2.5), ylim = c(0.5, 3), type = "n",
     xaxs = "i", yaxs = "i", bty = "n", xaxt = "n", yaxt = "n",
     xlab = "", ylab = "", pch = 19, asp = 1)
ea <- 0.06
arrows(c(0.5, 1, 1,  
         1, 1+ea, 2+ea,  
         0.5, 2, 2),
       c(1, 1+ea, 2+ea,  
         0.5, 2, 2,  
         2, 2-ea, 1-ea),
       c(1-ea, 1, 1,  
         1, 2-ea, 2.5,  
         1-ea, 2, 2),
       c(1, 2-ea, 2.5,  
         1-ea, 2, 2,  
         2, 1+ea, 0.5), 
       code = 2, length = 0.15,
       lwd = c(2, 4, 2,  2, 4, 2,  2, 2))
#points(grid, pch = 19, cex = 4, col = "white")
points(grid, pch = 19, cex = 2, col = "black")

tx <- rbind(c(0.7, 1.1), c(0.9, 1.5), c(0.9, 2.3),
            c(1.1, 0.7), c(1.5, 2.1), c(2.3, 2.1),
            c(0.7, 1.9), c(2.1, 1.5), c(2.1, 0.7))
for (i in 1:nrow(tx)) {
    text(tx[i,1], tx[i,2], 
         substitute(r[x], list(x = i)),
         cex = 3, family="serif", font=3)
}
     
@ 



\section{Real-time vehicle model: particle filter}
\label{sec:pf}

The primary goal of the particle filter is to estimate the unobservatble
vehicle state,
consisting of distance into trip ($d$), velocity ($v$),
current stop sequence ($s$), 
arrival and departure times at the last stop ($A_s$ and $D_s$),
current segment index ($r$),
the time spent queuing at the beginning of the current segment ($Q_r$),
and the time at which the vehicle began traveling along the current segment ($B_r$);
the vehicle state at time $k$ is denoted
\begin{equation}
  \label{eq:vehiclestate}
  \bX_k = [d_k, v_k, s_k, A_{s_k}, D_{s_k}, r_k, Q_{r_k}, B_{r_k}]^T.
\end{equation}

To estimate $\bX_k$, we use the observed data,
which comes from the realtime GTFS feed;
\begin{equation}
  \label{eq:data}
  \bY_k = [t_k, \phi_k, \lambda_k, j, T_j^a, T_j^d]^T,
\end{equation}
which is the observation time, latitude, longitude, stop index,
arrival time, and departure time, respectively.
The relationship between the GPS position ($\tilde \bY_k = [\phi_k, \lambda_k]^T$)
is denoted by a \emph{measurment function}, $\tilde\bY_k = h(\bX_k) = h(d_k)$,
which depends only on the distance into trip.
The \emph{stop time updates}, ($j, T^a_j , T^d_j$),
are recorded when the bus arrives or departs a stop;
either or both of the arrival or departure times can be missing.


The particle filter is used to model a transit vehicle,
so we need to know about the behaviour of these.
The vehicle itself has a purpose of driving along an \emph{a priori} known route,
stopping at stops with known location along the way to pick up
and drop off passengers, if there are any.
Between stops, vehicles travel as close to the posted speed limit as possible,
typically only stopping at intersections (if necessary).
Due to many conditional situations, 
the particle filter becomes a vastly superior model when compared to traditional
Kalman filter based methods, 
as it can easily deal with multimodality.

On approach to a stop $j$, the bus will stop with probability $\pi_j$ 
(i.e., it is a bernoulli trial for each particle).
If it stops, it will wait a minimum of $\gamma$ seconds while the doors are opened and closed,
and an additional $\bar t$ seconds as passengers board and disembark.
$\gamma$ is considered a fixed parameter, across all busses, 
while $\bar t$ is given an exponential distribution that, for now, has a fixed mean, $\tau$
(section~\ref{sec:discussion} discusses modifications to this).

On approach to an intersection (the end of a segment),
the behaviour is slightly different;
the vehicle doesn't reach the intersection itself, instead it joins the queue
(if there is one), and queues until it is able to pass through.
Similarly to stops, currently this is just modelled using fixed parameter values;
$\rho$ is the probability of stopping at the intersection
(for example, green vs.\ red traffic lights),
and $\kappa$ is the average queue time.


To implement the particle filter model (for a single vehicle $c$), 
we simply initialise $N_c$ particles (using superscript~${(i)}$ to identify an individual particle)
by sampling distance and velocity, and then determining $s_k$ and $r_k$ from the 
vectors of stop and segment distances, $\bS^d_r$ and $\bR^d_r$, respectively
(conditional on the route, $r$).
The remaining state parameters are NULL.
Each particle is then passed through the \emph{transition function} independently (the prediction step),
and then the vehicle state estimate is updated using the data by computing likelihood weights
and resampling the particles with replacement.
The steps are described below.


\subsection{Predict: transition function}
The idea behind using particle filter (as opposed to other models)
is that it is well suited modelling busses \cite{Hans_2015},
as it has good coverage of the plausible locations and thus overcomes
many problems associated with modelling transit vehicles,
such as multimodality (due to loops, traffic lights, and stops).

Also easy to describe the model;
only have to deal with an individual object (particle) which follows laws of physics.
Rather than dealing with a state \emph{distribution}.

Downside is computational demand.

Algorithm~1 describes the particle filter transition algorithm that
describes the motion of a bus between observations.
The $k$ subscripts and $(i)$ superscripts have been dropped from the
vehicle state parameters (e.g., $d \equiv d_k^{(i)}$).

The additional parameters are the noise terms, $\sigma_v^2$ and $\sigma_r^2$,
which represent system noise and between-segment speed variance respectively.
The former is assumed to be small, and represents the average change in speed
of a bus per second \emph{within a segment},
while the latter is the variance in speed \emph{between adjacent segments},
and allows for the bus to quickly change speed when passing through an intersection.


\begin{figure}[bt]
  \begin{algorithmic}
    \Function{transition}{$\bX$, $\delta$, $t$}
    
    \Phase{1}{initial wait time}
    \State $w\gets 0$
    \If {$A_s \neq$ NULL $\cap\ D_s =$ NULL}
      \Comment{at stop}
      \State $w\gets w + \max\{0, \gamma - (t - A_s)\}$
      \Comment{min dwell time}
      \State $\bar t \sim \mathcal{E}(\tau^{-1})$
      \State $w\gets w + \bar t, \delta\gets \delta - w$
      \If {$\delta > 0$}
        \State $D_s\gets t - \delta$
        \Comment{depart stop}
      \EndIf
    \ElsIf {$Q_r \neq$ NULL $\cap\ B_r =$ NULL}
      \Comment{at intersection}
      \State $\bar t \sim \mathcal{E}(\kappa^{-1})$
      \State $Q_r\gets Q_r + \bar t$, $w\gets w+\bar t$, $\delta\gets \delta - w$
      \If {$\delta > 0$}
        \State $B_s\gets t - \delta$
        \Comment{pass through intersection}
      \EndIf
    \EndIf
    \EndPhase
    
    
    \Phase{2}{System Noise}
    \State $v_k^{(i)}\sim \mathcal{N}(v, \delta\sigma_v^2)$
    \Comment{add system noise}
    \EndPhase
    
    \Phase{3}{Transition Forward}
    \State see figure~\ref{alg:transitionPhase3}
    \EndPhase
    
    \State \textbf{return} $\bX$
    \EndFunction
  \end{algorithmic}
  \caption{Particle filter transition function. Arguments are vehicle state~($\bX$), time since previous observation~($\delta$), and time of current observation ($t$).}
  \label{alg:transition}
\end{figure}


\begin{figure}[bt]
  \begin{algorithmic}
    \Phase{3}{Transition Forward}
    \While {$\delta > 0$}
      \If {$S^d_{s+1} \leq R^d_{r+1}$}
        \Comment{approaching stop}
        \State ETA  $\gets \frac{1}{v} (S^d_{s+1} - d)$
        \If {ETA $\leq \delta$}
        \Comment{reaches stop}
          \State $\delta\gets \delta - $ ETA, $s \gets s + 1$
          \State $A \gets t - \delta$, $D\gets $ null, $d\gets S^d_s$
          \If {$s = M$}
            \State\textbf{exit}
            \Comment{reached last stop}
          \EndIf
          \State $p\gets \mathcal{B}(\pi)$, $\bar t \sim \mathcal{E}(\tau^{-1})$
          \State dwell $\gets p(\gamma + \bar t)$, $\delta\gets \delta\ - $ dwell
          \If {$\delta > 0$}
            \State $D\gets t - \delta$
            \Comment{departs stop}
          \EndIf
        \Else
          \Comment{doesn't reach stop}
          \State $d\gets d + \delta v$, $\delta \gets 0$
        \EndIf
      \Else
        \Comment{approaching intersection}
        \State ETA $\gets \frac{1}{v}(R^d_{r+1} - d)$
        \If {ETA $\leq \delta$}
          \Comment{reaches intersection}
          \State $\delta\gets \delta - $ ETA, $r\gets r + 1$
          \State $Q \gets 0$, $B\gets $ null, $d\gets R^d_r$
          \State $p \sim \mathcal{B}(\rho)$, $\bar t \sim \mathcal{E}(\kappa^{-1})$
          \State queue $\gets p\bar t$, $\delta\gets \delta\ - $ queue
          \State $Q\gets Q\ +$ queue
          \If {$\delta > 0$}
            \Comment{makes it through intersection}
            \State $B\gets t - \delta$
            \State $v \sim \mathcal{N}(v, \sigma_r^2)$
          \EndIf
        \Else
          \Comment{doesn't reach intersection}
          \State $d\gets d + \delta v$, $\delta \gets 0$
        \EndIf
      \EndIf
    \EndWhile
    \EndPhase
  \end{algorithmic}
  \caption{Transition function, phase 3: the main phase in which particles are moved forwards along the route.}
  \label{alg:transitionPhase3}
\end{figure}



\subsection{Update: weighted resampling}


Several pieces of data: position, arrival time, and departure time.

For position, need to allow bus to be ``at stop'' (but not exactly),
or ``queued up at an intersection''.

For arrival/departure times, when the data is there, it's fairly easy;
however, if data is \emph{missing}, we don't know whether bus hasn't arrived yet,
or if bus didn't report arrival.
Also if bus doesn't report both arrival time and departure time,
don't know if it simply didn't stop (i.e., arrival = departure),
or if we missed one of them.

So, depending on the particles' states, we apply different likelihood functions.

\begin{enumerate}
%\subsubsection[L1]{$L_1$: not at a stop or intersection}
\item
In situations where the bus is neither at a bus stop nor at an intersection,
the likelihood is simply determined from the distance between the particle and 
vehicle's reported position.
The particle filter framework makes this easy,
as each particle has a single value of distance into trip, $d_k^{(i)}$,
with which we can compute the latitude and longitude values based on 
the routes shape information, $z_k^{(i)} = h(d_k^{(i)})$.
The function $g (\bZ | \tilde\bY)$ performs an \emph{equirectangular projection} \cite{Snyder_1998}
of the coordinates $\bX$, centered on $\tilde\bY$, 
onto a flat surface so that the Euclidean distance between points is equivalent
to the Great Circle distance between their associated coordinates.
This allows us to use a bivariate normal likelihood on the particles' positions,
with a GPS error of $\sigma_y^2$.

\begin{equation}
  \label{eq:l1}
  \log L_1 (\bY_k | \bX_k^{(i)}) = - \log(2\pi\sigma_y) - \frac{\|g(h(d_k^{(i)})|\tilde\bY_k)\|^2}{2\varepsilon_y^2}
\end{equation}


%\subsubsection[L1b]{$L_1'$: at stop}
\item
If the particle is considered to be at a stop, then we apply the following likelihood.
Define a parameter $\varepsilon_S$ as a boundary around the stop;
if observation is within that boundary likelihood is 1, else 0 (figure~\ref{fig:likelihood_circles}a).
Let $B_s$ be a circle with radius $\varepsilon_S$ and centered at stop $j$, then

\begin{equation}
  \label{eq:l1b}
  \log L_1(\bY_k | \bX_k^{(i)})=
  \begin{cases}
    - \log(\pi \varepsilon_S^2) & \tilde\bY_k \in B_s \\
    - \infty & \text{otherwise}
  \end{cases}
\end{equation}

%\subsubsection[L1c]{$L_1''$: at intersection}
\item
If the particle is considered to be at an intersection, we apply the following likelihood.
Similar to $L_1'$, however need to check observation is heading into the intersection
(and not out of it) by using two boundaries around the intersection and a point $\varepsilon_I$ away
(figure~\ref{fig:likelihood_circles}b).
Let $B_I^1$ and $B_I^2$ be two circles with radii $\varepsilon_I$,
the first centered on the intersection and the second centered $\varepsilon_I$ meters before it, then

\begin{equation}
  \label{eq:l1c}
  \log L_1 (\bY_k | \bX_k^{(i)}) =
  \begin{cases}
    - \log(A) & \tilde\bY_k \in B_I^1 \cap B_I^2 \\
    - \infty & \text{otherwise}
  \end{cases}
\end{equation}
where $A = 2\varepsilon_I^2 \left( \cos^{-1}(\frac{1}{2}) - \frac{\sqrt{3}}{4} \right)$,
the area of $B_I^1\cap B_I^2$.

\end{enumerate}


<<likelihood_circles,echo=FALSE,out.width='0.5\\linewidth',fig.cap="Likelihood functions for particle's at stops and intersections. The grey region represents the area where particle's are accepted.",fig.subcap=c("Stop", "Intersection")>>=
par(mar = rep(2.1, 4))
plot(NA, bty = "n", type = "n", xaxt = "n", yaxt = "n", xlim = 0:1, ylim = 0:1, asp = 1)
lines(c(0, 1), c(0.5, 0.5))
th <- seq(0, 360, length = 100) * pi / 180
polygon(cos(th) / 4 + 0.5, sin(th) / 4 + 0.5, col = "#cccccc")
lines(c(0, 1), c(0.5, 0.5), lty = "9999")
points(0.5, 0.5, pch = 19, cex = 4)

plot(NA, bty = "n", type = "n", xaxt = "n", yaxt = "n", xlim = 0:1, ylim = 0:1, asp = 1)
lines(c(0, 1), c(0.5, 0.5))
th <- seq(0, 360, length = 100) * pi / 180
th2 <- seq(-180, 180, length = 100) * pi / 180
lines(c1x <- cos(th) / 4 + 0.7, c1y <- sin(th) / 4 + 0.5, lty = "99")
lines(c2x <- cos(th2) / 4 + 0.7 - 0.25, c2y <- sin(th2) / 4 + 0.5, lty = "99")
wc1 <- c1x <= 0.7 - 0.25/2
wc2 <- c2x >= 0.7 - 0.25/2
polygon(c(c1x[wc1], c2x[wc2]), c(c1y[wc1], c2y[wc2]), col = "#cccccc")
lines(c(0, 1), c(0.5, 0.5), lty = "9999")
points(0.7, 0.5, pch = 19, cex = 4)
points(0.7 - 0.25, 0.5, pch = 15, cex = 3)
@ 





The second part of the likelihood involves the stop time update,
and how the likelihood is formed depends on what data is available,
where $\bT_k = \left[ j, T^a_j , T^d_j \right]^T$ 
are the stop index, arrival and departure times,
respectively, either of which can be NULL.

\begin{enumerate}
\item 
  If both $T^a_j$ and $T^d_j$ are NULL, 
  then there is no change to the likelihood;
  $ L_2  (\bT_k | \bX_k^{(i)}) = 1 $; else
  
\item
  If $s_k^{(i)} \neq j$ (particle's stop index isn't the same as the stop time update's stop sequence),
  then we check particle is plausible given the data:
  \begin{equation}
    \label{eq:l2a}
    L_2 (\bT_k | \bX_k^{(i)}) =
    \mathbbm{1}_{s_k^{(i)} > j\ \cap\ A_{s_k}^{(i)} > \max\{T_j^a,T_j^d\} > t_k}
  \end{equation}
  (defining $x > y$ as TRUE if either $x$ or $y$ are NULL to simplify notation); else
  

\item
  If departure time, $T^d_j$, is available only, for stop $j$, then we
  know the bus has departed stop $j$; therefore,
  \begin{equation}
    \label{eq:l2}
    L_2 (\bT_k | \bX_k^{(i)}) =
        f_N(T_j^d | D_j^{(i)}, \sigma_d^2) \mathbbm{1}_{D_j^{(i)}}
  \end{equation}
  where $f_N(x | \mu, \sigma^2)$ is the probability density of a normal distribution
  with mean $\mu$ and variance $\sigma^2$,
  and $\mathbbm{1}_Z = 0$ if $Z$ is NULL, and $1$ otherwise; else
  
\item
  If arrival time, $T^a_j$, is available only, then similarly
  \begin{equation}
    \label{eq:l2b}
    L_2  (\bT_k | \bX_k^{(i)}) =
      f_N(T_j^a | A_j^{(i)}, \sigma_d^2)
  \end{equation}
  Note that this does not assume the particle hasn't yet left the stop;
  the departure time could simply be missing data; else
  
\item
  If both arrival time and departure time are available, then
  \begin{equation}
    \label{eq:l2c}
    L_2  (\bT_k | \bX_k^{(i)}) =
        f_N(T_j^a| A_j^{(i)}, \sigma_d^2) f_E(T_k^\delta | D_k^{(i)} - A_k^{(i)}) \mathbbm{1}_{D_j^{(i)}}
  \end{equation}
  where $T_k^\delta = T_k^d - T_k^a$ is the observed dwell time at the stop,
  and $f_E(x | \lambda)$ is the probability density of an exponential distribution 
  with rate $\lambda$.
  
\end{enumerate}


We now determine the likelihood of each particle by combining $L_1$ and $L_2$;
\begin{equation}
  \label{eq:particle_likelihood}
  L (\bY_k | \bX_k^{(i)}) = L_1(\tilde\bY_k|\bX_k^{(i)}) L_2(\bT_k | \bX_k^{(i)}).
\end{equation}
This is then used to compute the weight of each particle,
\begin{equation}
  \label{eq:particle_weights}
  w_i = \frac{L (\bY_k | \bX_k^{(i)})}{\sum_{j=1}^N   L (\bY_k | \bX_k^{(j)})}.
\end{equation}

The resampling stage takes place at the beginning of each iteration for computational 
reasons (see section~\ref{sec:results}).
so we therefore use the weighted estimates of parameters in the next section.
However, the resampling is simply done using a standard weighted resampling 
algorithm with replacement.


\section{Real-time transport road network model: Kalman filter}
\label{sec:kf}

Now that each vehicle is modelled by a sample of particles,
we can use the speed estimates of busses along segments to estimate
the speed along them, regardless of the route.
In future we can add correlation structure between adjacent segments.

Use Kalman filter because we have one parameter, speed, 
which we expect to be unimodal and approximately Gaussian
(some busses travel faster or slower).

Use weighted speed estimates as data,
and weighted variance as measurement error.

Want to find the state,
\begin{equation}
  \label{eq:kf_state}
  \Theta = [\theta_1, \cdots, \theta_L]^T\quad\text{and}\quad
  \Xi = \diag(\xi_1, \cdots, \xi_L) = \bxi\eye_L,
\end{equation}
which are the mean and variance of each segement, respectively.


We run the Kalman filter every time we run the particle filter,
since it has a low cost, allowing the most recent data to be incorporated.
For each vehicle $c$, we have $N_c$ particles which we use to
compute the mean distance into trip and velocity,
\begin{equation}
  \label{eq:weighted_mean}
  \bar d_c = \sum_{i=1}^{N_c} w_c^{(i)} d_c^{(i)} \quad\text{and}\quad
  \bar v_c = \sum_{i=1}^{N_c} w_c^{(i)} v_c^{(i)},
\end{equation}
as well as the weighted sample variance,
\begin{equation}
  \label{eq:weighted_variance}
  \bar S_c^2 = \sum_{i=1}^{N_c} w_c^{(i)} (v_c^{(i)} - \bar v_c)^2,
\end{equation}
since $\sum_{i=1}^{N_c} w_c^{(i)} = 1\quad \forall c = 1,\ldots,C$.

Using $\bar d_c$, we can find the segment id corresponding to each busses most probable location,
and then combine all vehicle speed estimates for each segment.

In situations where multiple vehicles are in the same segment $\ell$, 
we can simply combine the estimates, using $C_\ell = $ number of vehicles in segment $\ell$ 
\cite{cn}.
\begin{equation}
  \label{eq:kf_data_estimates}
  \hat V_\ell = \frac{1}{C_\ell} \sum_{c=1}^{C_\ell} \bar v_j \quad\text{and}\quad
  \hat P_\ell = \frac{1}{C_\ell} \sum_{j=1}^{C_\ell} \left(\bar v_c^2 + \bar S_c^2\right) - \hat V_\ell^2
\end{equation}

Next is just the simple matter of applying the Kalman filter algorithm \cite{Anderson_2012} 
to the transport road network state,
using the data \mbox{$\hat\bV_k = [\hat V_1, \ldots, \hat V_L]$} as the observation vector
and \mbox{$\hat\bP_k = \diag(\hat P_1, \ldots, \hat P_L)$},
as the measurement error matrix.
The Kalman filter prediction equations are
\begin{align}
  \Theta_{k|k-1} &= \Theta_{k-1|k-1} \\
  \Xi_{k|k-1} &= \Xi_{k-1|k-1} + \bW_k
\end{align}
where $\bW_k \sim \mathcal{N}(0, \Delta_k\zeta^2\eye_L)$, $\zeta^2$ is the system noise parameter,
and $\Delta_k = t_k - t_{k-1}$.

The update equations simplify to
\begin{align}
  \bK_k &= \frac{\Xi_{k|k-1}}{\Xi_{k|k-1} + \hat\bP_k} \\
  \Theta_{k|k} &= \Theta_{k|k-1} + \bK_k(\bV_k - \Theta_{k|k-1}) \\
  \Xi_{k|k} &= (\eye_L - \bK_k) \Xi_{k|k-1}
\end{align}
which make use of the segment means and variances computed in~(\ref{eq:kf_data_estimates}).


\section{Arrival time prediction}
\label{sec:arrival_time}


Compare several methods:
current delay, current speed, and Kalman filter speed estimates.
Also include dwell distibutions at stops and intersections.


The final step is to predict the arrival time of every bus 
at all remaining stops along their respective routes.
Using the real-time transport network road state, 
we can predict how long it will take a bus to travel 
to each stop.


For segments \emph{without} stops,
we simply sample a travel time from the segment's state estimate
for each particle.
For segments with stops, however,
we only want a \emph{partial} travel time.
Most simply, this is based on proportionally how far into the segment
the stop is.
More complex situations could be investigated in the future,
one example might be to use \emph{sub-segments}.



\section{Application to Auckland Transport}
\label{sec:results}

- mention why weighted estimates stored rather than resampled 
(i.e., to keep trajectories of disbanded particles for analysis).

- model implemented in C++


\section{Discusion and Future Work}
\label{sec:discussion}

\begin{itemize}
\item removing ``partial'' segments at start/end of routes
\item enforcing max length of segments
\end{itemize}



\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,../reflist.bib}


\appendix[List of Symbols]

\begin{tabular}{ll}
  $N_c$ & number of particles for vehicle $c$ \\
  $C$ & number of vehicles \\
  $C_\ell$ & number of vehicles in segment $\ell$ \\
  $M$ ($M_r$) & number of stops (for given route $r$) \\
  $L$ ($L_r$) & number of segments (for given route $r$) \\
  $\bS^d_r, \bR^d_r$ & stop, intersection distances along route $r$ \\
  $t_k$ & time at observation $k$ \\
  $\bY_k$ & observation $k$ \\
  $\phi,\lambda$ & latitude, latitude \\
  $T^a_j, T^d_j$ & arrival, departure time at stop $j \in \{1, \ldots, M_s\}$ \\
  $\bX_k$ & vehicle state associated with obs $k$ \\
  $d$ & distance into trip (meters) \\
  $v$ & velocity (speed, meters per second) \\
  $s$ & stop index $\in \{1, \ldots, M_s\}$ \\
  $A_s, D_s$ & arrival, departure time at stop $s$ \\
  $r$ & segment index $\in \{1, \ldots, M_r\}$ \\
  $Q_r, B_r$ & queue time (seconds), begin time for segment $r$ \\
  $z$ & computed GPS position of a particle \\
  $\delta$ & time since last observation (seconds) \\
  $\pi$ & probability of stopping at a stop \\
  $\gamma$ & minimum dwell time (seconds) \\
  $\tau$ & mean dwell time (seconds) \\
  $\rho$ & probability of stopping at an intersection \\
  $\kappa$ & mean queue time at intersection \\
  $\sigma_v^2$ & system noise (particle filter) \\
  $\sigma_r^2$ & between segment velocity variability \\
  $\varepsilon_y^2, \varepsilon_d^2$ & GPS, arrival/departure time error \\
  $\varepsilon_S, \varepsilon_I$ & stop, intersection radius (meters) \\
  $w$ & particle weight \\
  $\Theta, \Xi$ & transport road state mean, variance \\
  $\hat V_\ell$ & mean speed of recent vehicles in segment $\ell$ \\
  $\hat P_\ell$ & estimated population variance of vehicle speeds in segment $\ell$ \\
  $\zeta^2$ & system noise (Kalman filter)
\end{tabular}

\vspace{1em}
Times are UNIX timestamps (seconds since 1 Janurary, 1970) unless stated otherwise.

\end{document}
