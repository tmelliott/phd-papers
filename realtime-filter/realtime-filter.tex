ke au%\documentclass[9pt]{IEEEtran}
\documentclass[draftcls,a4paper,onecolumn]{IEEEtran}\usepackage[]{graphicx}\usepackage[]{color}
%% maxwidth is the original width if it is less than linewidth
%% otherwise use linewidth (to make sure the graphics do not exceed the margin)
\makeatletter
\def\maxwidth{ %
  \ifdim\Gin@nat@width>\linewidth
    \linewidth
  \else
    \Gin@nat@width
  \fi
}
\makeatother

\definecolor{fgcolor}{rgb}{0.345, 0.345, 0.345}
\newcommand{\hlnum}[1]{\textcolor[rgb]{0.686,0.059,0.569}{#1}}%
\newcommand{\hlstr}[1]{\textcolor[rgb]{0.192,0.494,0.8}{#1}}%
\newcommand{\hlcom}[1]{\textcolor[rgb]{0.678,0.584,0.686}{\textit{#1}}}%
\newcommand{\hlopt}[1]{\textcolor[rgb]{0,0,0}{#1}}%
\newcommand{\hlstd}[1]{\textcolor[rgb]{0.345,0.345,0.345}{#1}}%
\newcommand{\hlkwa}[1]{\textcolor[rgb]{0.161,0.373,0.58}{\textbf{#1}}}%
\newcommand{\hlkwb}[1]{\textcolor[rgb]{0.69,0.353,0.396}{#1}}%
\newcommand{\hlkwc}[1]{\textcolor[rgb]{0.333,0.667,0.333}{#1}}%
\newcommand{\hlkwd}[1]{\textcolor[rgb]{0.737,0.353,0.396}{\textbf{#1}}}%
\let\hlipl\hlkwb

\usepackage{framed}
\makeatletter
\newenvironment{kframe}{%
 \def\at@end@of@kframe{}%
 \ifinner\ifhmode%
  \def\at@end@of@kframe{\end{minipage}}%
  \begin{minipage}{\columnwidth}%
 \fi\fi%
 \def\FrameCommand##1{\hskip\@totalleftmargin \hskip-\fboxsep
 \colorbox{shadecolor}{##1}\hskip-\fboxsep
     % There is no \\@totalrightmargin, so:
     \hskip-\linewidth \hskip-\@totalleftmargin \hskip\columnwidth}%
 \MakeFramed {\advance\hsize-\width
   \@totalleftmargin\z@ \linewidth\hsize
   \@setminipage}}%
 {\par\unskip\endMakeFramed%
 \at@end@of@kframe}
\makeatother

\definecolor{shadecolor}{rgb}{.97, .97, .97}
\definecolor{messagecolor}{rgb}{0, 0, 0}
\definecolor{warningcolor}{rgb}{1, 0, 1}
\definecolor{errorcolor}{rgb}{1, 0, 0}
\newenvironment{knitrout}{}{} % an empty environment to be redefined in TeX

\usepackage{alltt}

\usepackage{amsmath}
\usepackage{amsfonts}
\usepackage{bm}
\usepackage{bbm}
\usepackage{subfig}
\usepackage{algpseudocode}
\algblockdefx[Phase]{Phase}{EndPhase}[2]{\textbf{Phase #1:} #2}{\textbf{End Phase}\\}

\input{../symbols.tex}
\input{../glossary.tex}


\title{Modelling the Real Time State of a Public Transport Road Network}
\author{Tom~Elliott}
\IfFileExists{upquote.sty}{\usepackage{upquote}}{}
\begin{document}

\maketitle


\begin{abstract}
  Model all vehicles in the public transport system in real time.
  Particle filter model for each vehicle (bus),
  using observations of position (GPS coordinates) to infer distance into trip
  and velocity.
  Then use particle filter estimates of vehicle speed to estimate bus speed along
  road segments, independently of route.
  
\end{abstract}



\begin{IEEEkeywords}
  Public transport, real-time, particle filter, kalman filter
\end{IEEEkeywords}

\section{Introduction}
\label{sec:intro}


Modelling busses in real-time has been done for a while now.
Modelling the underlying state of the road network in order to improve 
travel time predictions has not been explored \ldots
Some looking into complex models for ``future'' travel times \cite{Julio2016}.


The basic idea:
GPS position $\rightarrow$ 
vehicle state (distance, segment, speed) $\rightarrow$
road segment state (speed) $\rightarrow$
travel time predictions



\section{The Data: GTFS database and route segmentation}
\label{sec:data}

Transit data has become increasingly accessible over the year.
Attibuted mostly to Google's \gls{gtfs}.
Two components to \gls{gtfs}: static and real-time.

Static contains information about routes, trips (one instance of a route at a scheduled time of day),
stop positions, stop times, route shapes.

Real-time provides vehicle positions (as GPS coordinates),
and trip updates (including stop time updates, i.e., arrival and departure times/delays).
Updated typically every 30~seconds or so.

Modelling a single trip or route is fairly simple to do with the raw \gls{gtfs} data.
However, difficult to combine information from different routes traveling along the same road segments.

We define a \emph{road segment} as a stretch of road used in a transit route between two intersections,
\emph{or} between a start/end stop of a route and an intersection.

Do this by identifying all intersections
(approximated by all traffic lights for now, since that's the data we have)
and segment routes at these points.
Modify \gls{gtfs} data so \emph{shapes} table becomes
\texttt{shapes}, \texttt{segments}, and \texttt{segment\_shapes}.

Thus as we add new routes, we don't need to create new segments
(except at start/end\ldots see section~\ref{sec:discussion}).


\begin{knitrout}
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{figure}
\subfloat[Routes\label{fig:route_segmentation1}]{\includegraphics[width=0.5\linewidth]{figure/route_segmentation-1} }
\subfloat[Segments\label{fig:route_segmentation2}]{\includegraphics[width=0.5\linewidth]{figure/route_segmentation-2} }\caption[Simplied diagram of overlapping routes]{Simplified unidirectional road network diagram, with (a) overlapping routes, and (b) the segments obtained by splitting the routes at intersections. Route 1 $ = \{r_1, r_2, r_3\}$, route 2 $=\{r_4,r_2,r_5,r_6\}$, and route 3 $=\{r_7,r_5,r_8,r_9\}$.}\label{fig:route_segmentation}
\end{figure}


\end{knitrout}



\section{Real-time vehicle model: particle filter}
\label{sec:pf}

The primary goal of the particle filter is to estimate the unobservatble
vehicle state,
consisting of distance into trip ($d$), velocity ($v$),
current stop sequence ($s$), 
arrival and departure times at the last stop ($A_s$ and $D_s$),
current segment index ($r$),
the time spent queuing at the beginning of the current segment ($Q_r$),
and the time at which the vehicle began traveling along the current segment ($B_r$);
the vehicle state at time $k$ is denoted
\begin{equation}
  \label{eq:vehiclestate}
  \bX_k = [d_k, v_k, s_k, A_{s_k}, D_{s_k}, r_k, Q_{r_k}, B_{r_k}]^T.
\end{equation}

The vehicle state is related to an observable state $\bY_k = [\phi_k, \lambda_k]$,
(which contains the latitude and longitude, respectively)
through a \emph{measurment function}, $\bY_k = h(\bX_k) = h(d_k)$,
which depends only on the distance into trip.

There is a second source of data, the \emph{stop time updates}:
\mbox{$\bT_k = \left[ j, T^a_j , T^d_j \right]^T$}
are the stop index, arrival and departure times,
respectively; 
either of the arrival or departure times can be missing.


The particle filter is used to model a transit vehicle,
so we need to know about the behaviour of these.
The vehicle itself has a purpose of driving along an \emph{a priori} known route,
stopping at stops with known location along the way to pick up
and drop off passengers, if there are any.
Between stops, vehicles travel as close to the posted speed limit as possible,
typically only stopping at intersections (if necessary).
Due to many conditional situations, 
the particle filter becomes a vastly superior model when compared to traditional
Kalman filter based methods, as it can easily encompass each of these plausible states.

On approach to a stop $j$, the bus will stop with probability $\pi_j$ 
(i.e., it is a bernoulli trial for each particle).
If it stops, it will wait a minimum of $\gamma$ seconds while the doors are opened and closed,
and an additional $\bar t$ seconds as passengers board and disembark.
$\gamma$ is considered a fixed parameter, across all busses, 
while $\bar t$ is given an exponential distribution that, for now, has a fixed mean, $\tau$
(section~\ref{sec:discussion} discusses modifications to this).

On approach to an intersection (the end of a segment),
the behaviour is slightly different;
the vehicle doesn't reach the intersection itself, instead it joins the queue
(if there is one), and queues until it is able to pass through.
Similarly to stops, currently this is just modelled using fixed parameter values;
$\rho$ is the probability of stopping at the intersection
(for example, green vs.\ red traffic lights),
and $\nu$ is the average queue time.


To implement the particle filter model, 
we simply initialise $N$ particles (using superscript $^{(i)}$ to identify an individual particle)
by sampling distance and velocity, and then determining $s_k$ and $r_k$ from the 
vectors of stop and segment distances, $\bS^d$ and $\bR^d$, respectively.
The remaining state parameters are NULL.
Each particle is then passed through the \emph{transition function} independently (the prediction step),
and then the vehicle state estimate is updated using the data by computing likelihood weights
and resampling the particles with replacement.
The steps are described below.


\subsection{Predict: transition function}
The idea behind using particle filter (as opposed to other models)
is that it is well suited modelling busses \cite{Hans2015},
as it has good coverage of the plausible locations and thus overcomes
many problems associated with modelling transit vehicles,
such as multimodality (due to loops, traffic lights, and stops).

Also easy to describe the model;
only have to deal with an individual object (particle) which follows laws of physics.
Rather than dealing with a state \emph{distribution}.

Downside is computational demand.

Algorithm~1 describes the particle filter transition algorithm that
describes the motion of a bus between observations.
The $k$ subscripts and $(i)$ superscripts have been dropped from the
vehicle state parameters (e.g., $d \equiv d_k^{(i)}$).

The additional parameters are the noise terms, $\sigma_v^2$ and $\sigma_r^2$,
which represent system noise and between-segment speed variance respectively.
The former is assumed to be small, and represents the average change in speed
of a bus per second \emph{within a segment},
while the latter is the variance in speed \emph{between adjacent segments},
and allows for the bus to quickly change speed when passing through an intersection.


\begin{figure}[bt]
  \begin{algorithmic}
    \Function{transition}{$\bX$, $\delta$, $t$}
    
    \Phase{1}{initial wait time}
    \State $w\gets 0$
    \If {$A_s \neq$ NULL $\cap\ D_s =$ NULL}
      \Comment{at stop}
      \State $w\gets w + \max\{0, \gamma - (t - A_s)\}$
      \Comment{min dwell time}
      \State $\bar t \sim \mathcal{E}(\tau^{-1})$
      \State $w\gets w + \bar t, \delta\gets \delta - w$
      \If {$\delta > 0$}
        \State $D_s\gets t - \delta$
        \Comment{depart stop}
      \EndIf
    \ElsIf {$Q_r \neq$ NULL $\cap\ B_r =$ NULL}
      \Comment{at intersection}
      \State $\bar t \sim \mathcal{E}(\nu^{-1})$
      \State $Q_r\gets Q_r + \bar t$, $w\gets w+\bar t$, $\delta\gets \delta - w$
      \If {$\delta > 0$}
        \State $B_s\gets t - \delta$
        \Comment{pass through intersection}
      \EndIf
    \EndIf
    \EndPhase
    
    
    \Phase{2}{System Noise}
    \State $v_k^{(i)}\sim \mathcal{N}(v, \delta\sigma_v^2)$
    \Comment{add system noise}
    \EndPhase
    
    \Phase{3}{Transition Forward}
    \State see figure~\ref{alg:transitionPhase3}
    \EndPhase
    
    \State \textbf{return} $\bX$
    \EndFunction
  \end{algorithmic}
  \caption{Particle filter transition function. Arguments are vehicle state~($\bX$), time since previous observation~($\delta$), and time of current observation ($t$).}
  \label{alg:transition}
\end{figure}


\begin{figure}[bt]
  \begin{algorithmic}
    \Phase{3}{Transition Forward}
    \While {$\delta > 0$}
      \If {$S^d_{s+1} \leq R^d_{r+1}$}
        \Comment{approaching stop}
        \State ETA  $\gets \frac{1}{v} (S^d_{s+1} - d)$
        \If {ETA $\leq \delta$}
        \Comment{reaches stop}
          \State $\delta\gets \delta - $ ETA, $s \gets s + 1$
          \State $A \gets t - \delta$, $D\gets $ null, $d\gets S^d_s$
          \If {$s = M$}
            \State\textbf{exit}
            \Comment{reached last stop}
          \EndIf
          \State $p\gets \mathcal{B}(\pi)$, $\bar t \sim \mathcal{E}(\tau^{-1})$
          \State dwell $\gets p(\gamma + \bar t)$, $\delta\gets \delta\ - $ dwell
          \If {$\delta > 0$}
            \State $D\gets t - \delta$
            \Comment{departs stop}
          \EndIf
        \Else
          \Comment{doesn't reach stop}
          \State $d\gets d + \delta v$, $\delta \gets 0$
        \EndIf
      \Else
        \Comment{approaching intersection}
        \State ETA $\gets \frac{1}{v}(R^d_{r+1} - d)$
        \If {ETA $\leq \delta$}
          \Comment{reaches intersection}
          \State $\delta\gets \delta - $ ETA, $r\gets r + 1$
          \State $Q \gets 0$, $B\gets $ null, $d\gets R^d_r$
          \State $p \sim \mathcal{B}(\rho)$, $\bar t \sim \mathcal{E}(\nu^{-1})$
          \State queue $\gets p\bar t$, $\delta\gets \delta\ - $ queue
          \State $Q\gets Q\ +$ queue
          \If {$\delta > 0$}
            \Comment{makes it through intersection}
            \State $B\gets t - \delta$
            \State $v \sim \mathcal{N}(v, \sigma_r^2)$
          \EndIf
        \Else
          \Comment{doesn't reach intersection}
          \State $d\gets d + \delta v$, $\delta \gets 0$
        \EndIf
      \EndIf
    \EndWhile
    \EndPhase
  \end{algorithmic}
  \caption{Transition function, phase 3: the main phase in which particles are moved forwards along the route.}
  \label{alg:transitionPhase3}
\end{figure}



\subsection{Update: weighted resampling}


Several pieces of data: position, arrival time, and departure time.

For position, need to allow bus to be ``at stop'' (but not exactly),
or ``queued up at an intersection''.

For arrival/departure times, when the data is there, it's fairly easy;
however, if data is \emph{missing}, we don't know whether bus hasn't arrived yet,
or if bus didn't report arrival.
Also if bus doesn't report both arrival time and departure time,
don't know if it simply didn't stop (i.e., arrival = departure),
or if we missed one of them.

So, depending on the particles' states, we apply different likelihood functions.

\begin{enumerate}
%\subsubsection[L1]{$L_1$: not at a stop or intersection}
\item
In situations where the bus is neither at a bus stop nor at an intersection,
the likelihood is simply determined from the distance between the particle and 
vehicle's reported position.
The particle filter framework makes this easy,
as each particle has a single value of distance into trip, $d_k^{(i)}$,
with which we can compute the latitude and longitude values based on 
the routes shape information, $z_k^{(i)} = h(d_k^{(i)})$.
The function $g (\bZ | \bY)$ performs an \emph{equirectangular projection} \cite{Snyder1997}
of the coordinates $\bX$, centered on $\bY$, 
onto a flat surface so that the Euclidean distance between points is equivalent
to the Great Circle distance between their associated coordinates.
This allows us to use a bivariate normal likelihood on the particles' positions,
with a GPS error of $\sigma_y^2$.

\begin{equation}
  \label{eq:l1}
  \log L_1 (\bY_k | \bX_k^{(i)}) = - \log(2\pi\sigma_y) - \frac{\|g(h(d_k^{(i)})|\bY_k)\|^2}{2\sigma_y^2}
\end{equation}


%\subsubsection[L1b]{$L_1'$: at stop}
\item
If the particle is considered to be at a stop, then we apply the following likelihood.
Define a parameter $\varepsilon_S$ as a boundary around the stop;
if observation is within that boundary likelihood is 1, else 0.
Let $B_s$ be a circle with radius $\varepsilon_S$ and centered at stop $j$, then

\begin{equation}
  \label{eq:l1b}
  \log L_1(\bY_k | \bX_k^{(i)})=
  \begin{cases}
    - \log(\pi \varepsilon_S^2) & \bY_k \in B_s \\
    - \infty & \text{otherwise}
  \end{cases}
\end{equation}

%\subsubsection[L1c]{$L_1''$: at intersection}
\item
If the particle is considered to be at an intersection, we apply the following likelihood.
Similar to $L_1'$, however need to check observation is heading into the intersection
(and not out of it) by using two boundaries around the intersection and a point $\varepsilon_I$ away.
Let $B_I^1$ and $B_I^2$ be two circles with radii $\varepsilon_I$,
the first centered on the intersection and the second centered $\varepsilon_I$ meters before it, then

\begin{equation}
  \label{eq:l1c}
  \log L_1 (\bY_k | \bX_k^{(i)}) =
  \begin{cases}
    - \log(A) & \bY_k \in B_I^1 \cap B_I^2 \\
    - \infty & \text{otherwise}
  \end{cases}
\end{equation}
where $A = 2\varepsilon_I^2 \left( \cos^{-1}(\frac{1}{2}) - \frac{\sqrt{3}}{4} \right)$,
the area of $B_I^1\cap B_I^2$.

\end{enumerate}

%\subsubsection[L2]{$L_2$: not at a stop}


The second part of the likelihood involves the stop time update,
and how the likelihood is formed depends on what data is available,
where $\bT_k = \left[ j, T^a_j , T^d_j \right]^T$ 
are the stop index, arrival and departure times,
respectively, either of which can be NULL.

\begin{enumerate}
\item 
  If both $T^a_j$ and $T^d_j$ are NULL, 
  then there is no change to the likelihood;
  $ L_2  (\bT_k | \bX_k^{(i)}) = 1 $; else
  
\item
  If $s_k^{(i)} \neq j$ (particle's stop index isn't the same as the stop time update's stop sequence),
  then we check particle is plausible given the data:
  \begin{equation}
    \label{eq:l2a}
    L_2 (\bT_k | \bX_k^{(i)}) =
    \mathbbm{1}_{s_k^{(i)} > j\ \cap\ A_{s_k}^{(i)} > T_j^a\ \cap\ A_{s_k}^{(i)} > T_j^d\
      \cap\ T^a_j > t_k\ \cap\ T^d_j > t_k}
  \end{equation}
  (defining $x > y$ as TRUE if either $x$ or $y$ are NULL to simplify notation); else
  

\item
  If departure time, $T^d_j$, is available only, for stop $j$, then we
  know the bus has departed stop $j$; therefore,
  \begin{equation}
    \label{eq:l2}
    L_2 (\bT_k | \bX_k^{(i)}) =
        f_N(T_j^d | D_j^{(i)}, \sigma_d^2) \mathbbm{1}_{D_j^{(i)}}
  \end{equation}
  where $f_N(x | \mu, \sigma^2)$ is the probability density of a normal distribution
  with mean $\mu$ and variance $\sigma^2$,
  and $\mathbbm{1}_Z = 0$ if $Z$ is NULL, and $1$ otherwise; else
  
\item
  If arrival time, $T^a_j$, is available only, then similarly
  \begin{equation}
    \label{eq:l2b}
    L_2  (\bT_k | \bX_k^{(i)}) =
      f_N(T_j^a | A_j^{(i)}, \sigma_d^2)
  \end{equation}
  Note that this does not assume the particle hasn't yet left the stop;
  the departure time could simply be missing data; else
  
\item
  If both arrival time and departure time are available, then
  \begin{equation}
    \label{eq:l2c}
    L_2  (\bT_k | \bX_k^{(i)}) =
        f_N(T_j^a| A_j^{(i)}, \sigma_d^2) f_E(T_k^\delta | D_k^{(i)} - A_k^{(i)}) \mathbbm{1}_{D_j^{(i)}}
  \end{equation}
  where $T_k^\delta = T_k^d - T_k^a$ is the observed dwell time at the stop,
  and $f_E(x | \lambda)$ is the probability density of an exponential distribution 
  with rate $\lambda$.
  
\end{enumerate}


We now determine the likelihood of each particle by combining $L_1$ and $L_2$;
\begin{equation}
  \label{eq:particle_likelihood}
  L ([\bY_k, \bT_k] | \bX_k^{(i)}) = L_1(\bY_k|\bX_k^{(i)}) L_2(\bT_k | \bX_k^{(i)}).
\end{equation}
This is then used to compute the weight of each particle,
\begin{equation}
  \label{eq:particle_weights}
  w_i = \frac{L ([\bY_k, \bT_k] | \bX_k^{(i)})}{\sum_{j=1}^N   L ([\bY_k, \bT_k] | \bX_k^{(j)})}.
\end{equation}

The resampling stage takes place at the beginning of each iteration for computational 
reasons (see section~\ref{sec:results}).
so we therefore use the weighted estimates of parameters in the next section.
However, the resampling is simply done using a standard weighted resampling 
algorithm with replacement.


\section{Real-time transport road network model: Kalman filter}
\label{sec:kf}

Now that each vehicle is modelled by a sample of particles,
we can use the speed estimates of busses along segments to estimate
the speed along them, regardless of the route.
In future we can add correlation structure between adjacent segments.

Use Kalman filter because we have one parameter, speed, 
which we expect to be unimodal and approximately Gaussian
(some busses travel faster or slower).

Use weighted speed estimates as data,
and weighted variance as measurement error.


We run the Kalman filter every time we run the particle filter,
since it has a low cost, allowing the most recent data to be incorporated.
We have $N$ weighted particle estimates of vehicle state for each bus,
with which we can compute the mean distance into trip and velocity for bus $j$,
\begin{equation}
  \label{eq:weighted_mean}
  \bar d_j = \sum_{i=1}^N w_j^{(i)} d_j^{(i)} \quad\text{and}\quad
  \bar v_j = \sum_{i=1}^N w_j^{(i)} v_j^{(i)},
\end{equation}
as well as the weighted sample variance \cite{cn},
\begin{equation}
  \label{eq:weighted_variance}
  \bar S_j^2 = \sum_{i=1}^N w_j^{(i)} (v_j^{(i)} - \bar v_j)^2,
\end{equation}
since $\sum_{i=1}^N w_j^{(i)} = 1\quad \forall j$.

Using $\bar d_j$, we can find the segment id corresponding to each busses most probable location,
and then combine all vehicle speed estimates for each segment.

In situations where multiple vehicles are in the same segment $\ell$, 
we can simply combine the estimates, using $M_\ell = $ number of vehicles in segment $\ell$ 
\cite{cn}.
\begin{equation}
  \label{eq:kf_data_estimates}
  \bar z_\ell = \frac{1}{M_\ell} \sum_{j = 1}^{M_\ell} \bar v_j \quad\text{and}\quad
  \hat \bR_{\ell,\ell}^2 = \frac{1}{M_\ell} \sum_{j=1}^{M_\ell} \left(\bar v_j^2 + \bar S_j^2\right) - \bar z_\ell^2
\end{equation}

Next is just the simple matter of applying the Kalman filter algorithm to the transport road network state,
using the data $\bz_k$ as the observation and $\bR_k$,
as the measurement error matrix.


\section{Arrival time prediction: application to a small subset of routes}
\label{sec:results}


Compare several methods:
current delay, current speed, and Kalman filter speed estimates.
Also include dwell distibutions at stops and intersections.

- mention why weighted estimates stored rather than resampled 
(i.e., to keep trajectories of disbanded particles for analysis).

- model implemented in C++


\section{Discusion and Future Work}
\label{sec:discussion}

\begin{itemize}
\item removing ``partial'' segments at start/end of routes
\item enforcing max length of segments
\end{itemize}



\bibliographystyle{IEEEtran}
\bibliography{IEEEabrv,../reflist.bib}


\end{document}
