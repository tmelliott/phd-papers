---
title: Section Three

header-includes:
   - \usepackage{cleveref}
   - \usepackage{booktabs}
   - \input{../symbols.tex}
---

```{r,echo=FALSE}
knitr::opts_chunk$set(fig.path="figures/")
```

# Predicting arrival time
@label:sec:pred_arrival;

Accurate, reliable prediction of bus arrival time requires knowledge of both vehicle and network states, represented by $\Vstate_{k}$ and $\NWstate_{c}$, respectively. Since there is a high degree in the uncertainty of these, particularly when forecasting future network states around peak times, it is crucial to incorporate this uncertainty into the arrival time distribution and, ultimately, decision making processes.

The particle filter presents a robust method of sampling all of the possible trajectories the vehicle might take @citep:Hans_2015;.

* initial state incoporates uncertainty (shape, multimodality) of vehicle state
* trajectory of each particle = one possible path the bus might take
* accounts for uncertainty in (forecasted) road speed, correlations, etc
* result makes no assumptions about shape of distribution

The main downside of the particle filter is the computational demand of it, often requiring 5000-10000 particles per bus.

* @cite:Elliott_2020; showed the pf is feasible in real-time for modelling
* need to also show predicions can be done quickly and usefully
* reduce number of particles where possible

Our implementation is described in @cref:pf_etas;. To examine the effectiveness of our approach, we run our method on a full day and compared the predictions with the actual arrivals, as well as the currently used "GTFS" predictions. These are discussed in @cref:pf_results;.


## Particle filter ETAs
@label:pf_etas;

In our application, the vehicle state is already represented by a set of $\Np$\ particles,
\[
p(\Vstate_{k|k}\cond{}\Vobs_k) \approx \sum_{i=1}^\Np \Pwt_k \DiracMeasure{\Vstate_k\vi}{\Vstate_k}
\]
which we use directly. However, were vehicle states available in some other form, one would simply take a sample from the posterior state estimate $p(\Vstate_{k|k}\cond{}\Vobs_k)$. This gives us a sample of plausible bus states for which we can predict individual arrival times at upcoming stops.

As with the vehicle model described by @citet:Elliott_2020;, we can iteratively forecast each particle's arrival at all upcoming stops. This involves incorporating network state (vehicle speeds along roads) as well as bus stopping behaviour. These two aspects are described individually below, and each particle simply iterates between them until it reaches the end of the route.

To begin, we define the state of an active trip at time $\Tript_k$ in which the vehicle is at or last visited stop $\TripStop_k$, together with an indicator $\TripDep_k$ of whether or not the bus has departed the stop, the index of the current road segment $\TripSeg_k$, and the progress along that segment $\SegProg_k$:
\[
   \Tripr_k = \tvec{\Tript_k, \TripStop_k, \TripDep_k, \TripSeg_k, \SegProg_k}.
\]

Next, we approximate the distribution of trip state by generating a sample of particles from $p(\Tripr_k | \Vobs_{1:k})$. In our case, we already have a weighted sample of particles, but the sample could be taken from any posterior distribution, for example if vehicle state is estimated using a Kalman filter the particles can be sampled from the Gaussian state estimate.

We wish to take a sample of size $\tilde N \leq N$, which can depend on the number of remaining stops and the level of accuracy desired. However, in the next section we approximate the predictive distributions using a discrete CDF, so accuracy only needs to be at about the 30\ second level. Thus, we pull sample with replacement from $p(\Vstate_k|\Vobs_{1:k})$, yielding the trip state estimate
\[
   p(\Tripr_k | \Vobs_{1:k}) \approx
   \frac{1}{\tilde N} \sum_{i=1}^{\tilde N} \DiracMeasure{\Tripr_k\vi}{\Tripr_k}
\]
where the components of $\Tripr_k\vi$ are computed from the vehicle state particles. This doesn't make sense. Gosh darnit.

Assuming I can rewrite the above to make sense ...

Now we iterate each trip particle to the end of the route, storing the arrival times at all stops along the way. This is a five-step process.

Note: need to add current speed to trip state ???

**Step 1: complete the current segment**

Each particle has completed 100$p_\ell\vi$% of the segment. If the vehicle is nearing the end of the segment (less than 200\ meters remaining), we keep the particle's initial speed $\Vspeed_k\vi$. Otherwise, we simulate a speed from the network state with mean $\NWstate_\ell$, uncertainty $\NWstatevar_\ell$, and between-vehicle variability $\NWvar_\ell$, as follows:
\begin{equation*}
   v_\ell{\vi}^\star =
   \begin{cases}
      \Vspeed_k\vi & (1-\SegProg_k)\Tseglen_\ell < 200, \\
      v_\ell{\vi} \sim \TNormal{\NWstate_\ell}{\RouteNWstatevarseg_\ell^2 + \NWvar_\ell^2}{0}{\MaxSpeed_\ell}, & \text{otherwise}.
   \end{cases}
\end{equation*}

Now the travel time to the end of the current segment can simply be obtained as
\[
   \tilde z\vi = \frac{(1-\SegProg_k\vi)\Tseglen_\ell}{\Vspeed_\ell{\vi}^\star}.
\]
We now store an iterative variable *travel-time-so-far* with the time taken to reach the end of the current segment, $\ttsofar\vi = \tilde z\vi$.

**Step 2: compute arrival time at next stop**

If there are any remaining segments between the current segment $\TripSeg_k\vi$ and the next stop $j_k\vi + 1$, their travel times are sampled from the network state with variance increased by network system noise to account for forecasting changes.
\[
   v_j\vi \sim
   \TNormal{\hat \NWstate_j}{\left[(\RouteNWstatevarseg_j + \ttsofar\vi\NWnoise)^2 + \NWvar_j^2\right]\wedge P_{\text{max}}}{0}{\MaxSpeed_j},
\]
allowing uncertainty to increase up to a maximum $P_\text{max}$ which is the overall variance of all speeds along all segments estimated from historical data. The travel time along each segment is added to the travel-time-so-far,
\[
   \ttsofar\vi = \ttsofar\vi + \frac{\Tseglen_j}{v_j\vi}.
\]

Now, arrival time at stop $j$ is the sum of travel time along all segments up to the next stop. In the iterative process, this is simply $\Tarr_j\vi = t_k + \ttsofar\vi$.


**Step 3: compute stop dwell time**

Once at a stop, a bus either stops and waits while passengers board and disembark, or travels past without stopping. This *dwell time* needs to be modelled @citep:cn;, but adds multimodality to the arrival time distribution.

The dwell time model is ... [from chapter 3], as used by @citet:Hans_2015,Elliott_2020;. This now gets added to the travel-time-so-far,
\[
   \ttsofar\vi = \ttsofar\vi + \pdwell_j\vi
\]
unless the stop is a layover. In that case, we allow the particle---with some probability---to remain at the stop until the end of the dwell time, or the scheduled departure time, whichever is later.


**Step 4: repeat steps 2--3**

We now repeat each of the steps, sampling travel times for intermediary road segments as the particle arrives, and storing stop arrival times, until the particle reaches the end of the route.


**Step 5: obtain arrival time distributions**

Since each particle stores its arrival at all stops, we can very easily obtain the predictive distribution of arrival time for the bus using the delta measure,
\[
   p(\Tarr_j | \Vstate_k, \vec\NWstate_k) \approx
   \frac{1}{\tilde N}\sum_{i=1}^{\tilde N}
      \DiracMeasure{\Tarr_j\vi}{\Tarr_j}.
\]
We may obtain any summary statistics from this distribution, including the mean and prediction intervals.


## Results
@label:pf_results;

```{r load_results,echo=FALSE,cache=TRUE,message=FALSE}
library(tidyverse)
library(tidyselect)
load("../data/etadata.rda")
```

To assess the feasibility and reliability of this approach, we ran the full model on one day of data from DATE. This used the particle filter and network model described by @cite:Elliott_2020;, and the arrival time predictions described above. At the end of the day, we could compare the predicted with the actual arrival times. In addition, we compare to the GTFS-based predictions which are simply the scheduled arrival time plus the delay at the most recent stop.

To assess, we use RMSE, MAE, MAPE, and PICP. RMSE and MAE provide an assessment of the absolute prediction reliability, while MAPE scales predictions by the time-until-arrival; that is, it is more affected by short-term predictions when the bus is near, giving us a comparative measure of short-term reliability (which is useful when deciding between walking, jogging, or sprinting to the bus stop). PICP (which is only available for the particle filter estimates) assess how well the uncertainty is captured (we would expect a 95% prediction interval to capture the true value in 95% of cases).

The overall values are shown in @cref:tab:overall_results;. The particle filter predictions are slightly more accurate than GTFS on average, and have about 20% error versus GTFS's 27%. However, only 77% of prediction intervals contain the actual arrival time, indicating that uncertainties are being under-predicted (the nominal coverage is 85%).

```{r overall_results,echo=FALSE,cache=TRUE,results="asis",dependson="load_results"}
res_overall <- eta_talk %>%
   filter(time_until_arrival > 0) %>%
   summarize(
      pf_rmse = sqrt(mean(pf_error^2)),
      pf_mae = mean(abs(pf_error)),
      pf_mape = mean(abs(pf_error / time_until_arrival)) * 100,
      pf_cicov = mean(pf_ci) * 100,
   #   pf_ci_width = mean(pf_upper - pf_lower),
   #   pf_ci_lower = quantile(pf_upper - pf_lower, 0.025),
   #   pf_ci_upper = quantile(pf_upper - pf_lower, 0.975),
      gtfs_rmse = sqrt(mean(gtfs_error^2)),
      gtfs_mae = mean(abs(gtfs_error)),
      gtfs_mape = mean(abs(gtfs_error / time_until_arrival)) * 100
   ) %>%
   pivot_longer(everything(),
      names_to = c("model", ".value"),
      names_pattern = "([a-z]*)_(.*)"
   ) %>%
   mutate(
      model = c("Particle filter", "Schedule-delay")
   ) %>%
   rename(
      " " = "model",
      "RMSE (s)" = "rmse",
      "MAE (s)" = "mae",
      "MAPE (%)" = "mape",
      "PICP (%)" = "cicov"
   )

opts <- options(knitr.kable.NA = "")
knitr::kable(res_overall, #"latex",
   booktabs = TRUE,
   # table.envir = "table",
   digits = 0,
   caption = "Results for particle filter and other."
)
options(opts)
```

Since traffic and bus numbers change over the course of a day, we also computed the assessment statistics over 15\ minute intervals. These results are shown in @cref:fig:day_results;, and immediately we can see the sizeable affect of peak time of predictive accuracy. This suggests that, during off-peak time when traffic conditions are stable, the real-time predictions are a vast improvement on the status quo. Since the underlying network model is not yet enabled to handle forecasts, its not surprising that accuracy and uncertainty coverage is lacking.

```{r day_results,echo=FALSE,fig.width=8,fig.height=4,message=FALSE,warning=FALSE,cache=TRUE,fig.cap="\\label{fig:day_results}Prediction accuracy results for the particle filter and GTFS methods.",dependson="load_results"}
library(patchwork)

res_timeofday <- eta_talk %>%
    mutate(
        hour = timestamp %>% format("%H") %>% as.integer,
        minute = timestamp %>% format("%M") %>% as.integer,
        hour = hour + (floor(minute / 15) * 15 / 60)
    ) %>%
    filter(time_until_arrival > 0) %>%
    group_by(hour) %>%
    summarize(
        pf_rmse = sqrt(mean(pf_error^2)),
        pf_mae = mean(abs(pf_error)),
        pf_mape = mean(abs(pf_error / time_until_arrival)),
        pf_ci_cov = mean(pf_ci),
        pf_ci_width = mean(pf_upper - pf_lower),
        pf_ci_lower = quantile(pf_upper - pf_lower, 0.025),
        pf_ci_upper = quantile(pf_upper - pf_lower, 0.975),
        gtfs_rmse = sqrt(mean(gtfs_error^2)),
        gtfs_mae = mean(abs(gtfs_error)),
        gtfs_mape = mean(abs(gtfs_error / time_until_arrival))
    ) %>% arrange(hour)

pal <- viridis::magma(3)[2:1] #RColorBrewer::brewer.pal(2, "Set1")
names(pal) <- c("Particle filter", "GTFS")

plot_base <- ggplot(res_timeofday, aes(hour)) +
    theme_classic() +
    theme(legend.position = "none") +
    scale_colour_manual(values = pal, name = "") +
    xlab("Time of day (hour)")

plot_rmse <- plot_base +
    geom_path(aes(y = pf_rmse, colour = "Particle filter")) +
    geom_path(aes(y = gtfs_rmse, colour = "GTFS"), alpha = 0.5) +
    scale_y_continuous(
        "RMSE (s)"
        # trans = "log10"
    ) +
    theme(legend.position = "bottom")

plot_mae <- plot_base +
    geom_path(aes(y = pf_mae, colour = "Particle filter")) +
    geom_path(aes(y = gtfs_mae, colour = "GTFS"), alpha = 0.5) +
    scale_y_continuous(
        "MAE (s)"
        # trans = "log10"
    )

plot_mape <- plot_base +
    geom_path(aes(y = 100 * pf_mape, colour = "Particle filter")) +
    geom_path(aes(y = 100 * gtfs_mape, colour = "GTFS"), alpha = 0.5) +
    scale_y_continuous(
        "MAPE (%)"
        # trans = "log10"
    )

plot_ci <- plot_base +
    geom_hline(aes(yintercept = 85), lty = 2) +
    geom_path(aes(y = 100 * pf_ci_cov, colour = "Particle filter")) +
    scale_y_continuous(
        name = "PICP (%)"
    )

plot_rmse + plot_mae +
    plot_mape + plot_ci +
    guide_area() +
    plot_layout(
        guides = "collect",
        design = "
            13
            24
            55
        ",
        heights = c(1, 1, 0.1)
    )
```
